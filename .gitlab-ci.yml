stages:
  - build
  - deploy_dev
  - deploy_prod
  - info_dev

variables:
  GIT_STRATEGY: clone

default:
  tags:
    - tfprod-distributed-werf

.before_script:
  before_script:
    - |
      type trdl && . $(trdl use werf 1.2 stable)
      type werf && source $(werf ci-env gitlab --as-file)

      # Login to the registry
      export DOCKER_CONFIG=$(mktemp -d)
      if [[ ${MODULE_NAME} == "" ]]; then
        export MODULE_NAME=${CI_PROJECT_NAME};
      fi

      docker login ${REGISTRY} -u ${REGISTRY_LOGIN} -p ${REGISTRY_PASSWORD}

      # {     REGISTGRY     }{ PATH }{ MODULE_NAME }
      # registry.example.com/modules/virtualization
      export WERF_REPO="${REGISTRY}/${REGISTRY_PATH}/${MODULE_NAME}"


      PROJECT_TAGS_URL="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/repository/tags"

      echo "${PROJECT_TAGS_URL}"
      curl -H "PRIVATE-TOKEN: $GITLAB_API_TOKEN" "${PROJECT_TAGS_URL}" | jq .

      # Hack to generate a tag for the dev version. Check if CI_COMMIT_REF_NAME matches semver. If not, we get the last tag via gitlab API, add the hash of the last commit to it and override CI_COMMIT_REF_NAME.

      if ! [[ $CI_COMMIT_REF_NAME =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "CI_COMMIT_REF_NAME is not semver, getting the latest tag and generate dev version"
          latest_tag=$(curl -sq -H "PRIVATE-TOKEN: $GITLAB_API_TOKEN" "${PROJECT_TAGS_URL}" | jq .[0].name -r)
          dev_version="${latest_tag}-${CI_COMMIT_SHORT_SHA}"
          echo "${dev_version}"
          export CI_COMMIT_REF_NAME=${dev_version}
      fi


.build_sctipt:
  script:
    - |
      # Build
      werf helm dep update
      werf build --save-build-report --build-report-path images_tags_werf.json

      # Bundle image ===========================================================

      # IMAGE_SRC registry.example.com/modules/virtualization:52cd3d08aded45c0ad260e8118b9e77a026c12a7def3ef7f9bd7bdb5-1691940564755
      IMAGE_SRC="$(jq -r '.Images."bundle".DockerImageName' images_tags_werf.json)"

      # REPO registry.example.com/modules/virtualization
      REPO="$(jq -r '.Images.bundle.DockerRepo' images_tags_werf.json)"

      # registry.example.com/modules/virtualization:${CI_COMMIT_REF_NAME}
      docker pull ${IMAGE_SRC}
      docker image tag ${IMAGE_SRC} ${REPO}:${CI_COMMIT_REF_NAME}
      docker image push ${REPO}:${CI_COMMIT_REF_NAME}
      docker image rmi ${REPO}:${CI_COMMIT_REF_NAME} || true;

      # Release-channel image ==================================================

      # IMAGE_SRC registry.example.com/modules/virtualization:0f6fe98c4087bddfb8c7afe262f0bc529c23c86a345db1de193f711f-1691937185066
      IMAGE_SRC="$(jq -r '.Images."release-channel-version".DockerImageName' images_tags_werf.json)"

      # REPO registry.example.com/modules/virtualization
      REPO="$(jq -r '.Images."release-channel-version".DockerRepo' images_tags_werf.json)"

      # registry.example.com/modules/virtualization/release:${CI_COMMIT_REF_NAME}
      docker pull ${IMAGE_SRC}
      docker image tag ${IMAGE_SRC} ${REPO}/release:${CI_COMMIT_REF_NAME}
      docker image push ${REPO}/release:${CI_COMMIT_REF_NAME}
      docker image rmi ${REPO}/release:${CI_COMMIT_REF_NAME} || true;

      # Register module ========================================================
      # registry.example.com/modules/virtualization
      docker pull spotify/scratch
      docker image tag spotify/scratch:latest ${REGISTRY}/${REGISTRY_PATH}:${MODULE_NAME}
      docker image push ${REGISTRY}/${REGISTRY_PATH}:${MODULE_NAME}
      docker image rmi ${REGISTRY}/${REGISTRY_PATH}:${MODULE_NAME} || true

.deploy_script:
  script:
    - |
      IMAGE_SRC="${WERF_REPO}/release:${CI_COMMIT_REF_NAME}"
      IMAGE_DST="${WERF_REPO}/release:${RELEASE_CHANNEL}"
      docker pull ${IMAGE_SRC}
      docker image tag ${IMAGE_SRC} ${IMAGE_DST}
      docker image push ${IMAGE_DST}
      docker image rmi ${IMAGE_DST} || true;

# PROD registry
.prod_registry_vars:
  variables:
    REGISTRY: ${EXTERNAL_MODULES_REGISTRY}
    REGISTRY_PATH: ${EXTERNAL_MODULES_REGISTRY_PATH}
    REGISTRY_LOGIN: ${EXTERNAL_MODULES_REGISTRY_LOGIN}
    REGISTRY_PASSWORD: ${EXTERNAL_MODULES_REGISTRY_PASSWORD}

# DEV registry
.dev_registry_vars:
  variables:
    REGISTRY: ${EXTERNAL_MODULES_DEV_REGISTRY}
    REGISTRY_PATH: ${EXTERNAL_MODULES_DEV_REGISTRY_PATH}
    REGISTRY_LOGIN: ${EXTERNAL_MODULES_DEV_REGISTRY_LOGIN}
    REGISTRY_PASSWORD: ${EXTERNAL_MODULES_DEV_REGISTRY_PASSWORD}

.prod_rules:
  only:
    - tags
  except:
    - main
  when: manual

.dev_rules:
  only:
    - merge_requests
  when: always

build_prod:
  stage: build
  extends:
    - .prod_registry_vars
    - .before_script
    - .build_sctipt
    - .prod_rules

build_dev:
  stage: build
  extends:
    - .dev_registry_vars
    - .before_script
    - .build_sctipt
    - .dev_rules

deploy_to_dev_channel:
  stage: deploy_dev
  variables:
    RELEASE_CHANNEL: mr-${CI_MERGE_REQUEST_IID}
  extends:
    - .dev_registry_vars
    - .before_script
    - .deploy_script
    - .dev_rules

deploy_to_prod_channels:
  stage: deploy_prod
  extends:
    - .prod_registry_vars
    - .before_script
    - .prod_rules
    - .deploy_script
  parallel:
    matrix:
      - RELEASE_CHANNEL:
          - alpha
          - beta
          - early-access
          - stable

show_module_manifest:
  stage: info_dev
  variables:
    RELEASE_CHANNEL: mr-${CI_MERGE_REQUEST_IID}
  extends:
    - .dev_registry_vars
    - .dev_rules
  script:
  - |
    cat << EOF
      ---
      apiVersion: deckhouse.io/v1alpha1
      kind: ExternalModuleSource
      metadata:
        name: ${MODULE_NAME}
      spec:
        releaseChannel: ${RELEASE_CHANNEL}
        registry:
          repo: ${REGISTRY}/${REGISTRY_PATH}
          dockerCfg: <base64 encoded credentials for ${REGISTRY}>
      ---
      apiVersion: deckhouse.io/v1alpha1
      kind: ModuleConfig
      metadata:
        name: ${MODULE_NAME}
      spec:
        enabled: true
        settings: {}
        version: 1
    EOF
