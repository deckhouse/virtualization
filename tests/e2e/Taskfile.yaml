version: "3"

silent: true

vars:
  VERSION: "v1.0.0"

tasks:
  copy:
    cmds:
      - |
        if [ "{{OS}}" == "darwin" ]; then
          rm -rf /tmp/testdata
        else
          rm --force --recursive /tmp/testdata
        fi
        cp -a testdata /tmp/testdata

  kubectl:
    cmds:
      - |
        if ! which kubectl >/dev/null ; then
          echo "kubectl not found or not in PATH"
          exit 1
        fi
  d8:
    cmds:
      - |
        if ! which d8 >/dev/null ; then
          echo "d8 not found or not in PATH. Install from https://github.com/deckhouse/deckhouse-cli/releases"
          exit 1
        fi
  run:ci:
    desc: "Separate task to run e2e tests in the CI environment"
    deps:
      - copy
      - kubectl
      - d8
    cmds:
      - ./task_run_ci.sh

  runp:
    desc: "Run e2e tests"
    deps:
      - copy
      - kubectl
      - d8
    cmds:
      - |
        go tool ginkgo -v \
          -p --procs=12 \
          --race \
          {{if .LABELS -}}
          --label-filter="{{ .LABELS }}" \
          {{end -}}
          {{if .TIMEOUT -}}
          --timeout={{ .TIMEOUT }} \
          {{else -}}
          --timeout=3h \
          {{end -}}
          {{if .FOCUS -}}
          --focus "{{ .FOCUS }}"
          {{end -}}

  run:
    desc: "Run e2e tests"
    deps:
      - copy
      - kubectl
      - d8
    cmds:
      - |
        go tool ginkgo -v \
          --race \
          {{if .LABELS -}}
          --label-filter="{{ .LABELS }}" \
          {{end -}}
          {{if .TIMEOUT -}}
          --timeout={{ .TIMEOUT }} \
          {{else -}}
          --timeout=3h \
          {{end -}}
          {{if .FOCUS -}}
          --focus "{{ .FOCUS }}" \
          {{end -}}
          {{if .JUNIT_PATH -}}
          --junit-report="{{ .JUNIT_PATH }}"
          {{end -}}
  cleanup:
    desc: "Cleanup namespaces & resources left from e2e tests"
    deps:
      - kubectl
      - d8
    cmds:
      - |
        if [ -z "$E2E_PREFIX" ]; then
          E2E_PREFIX="head-$(git rev-parse --short HEAD)"
          echo "E2E_PREFIX not set. Setting E2E_PREFIX to $E2E_PREFIX"
        else
          echo "Using existing E2E_PREFIX: $E2E_PREFIX"
        fi

        delete_resources_with_prefix() {
            local RESOURCE_TYPE=$1
            local RESOURCES=$(kubectl get "$RESOURCE_TYPE" --no-headers 2>/dev/null | awk "/$E2E_PREFIX/ {print \$1}")
            if [[ -n "$RESOURCES" ]]; then
              echo "Deleting $RESOURCE_TYPE:"
              echo "$RESOURCES" | awk '{print "  - " $1}'
              echo "$RESOURCES" | xargs -r kubectl delete "$RESOURCE_TYPE"
            else
                echo "No $RESOURCE_TYPE found with prefix $E2E_PREFIX"
            fi
        }

        delete_resources_with_prefix "namespaces"

        delete_resources_with_prefix "projects"

        readarray -t CLEANUP_RESOURCES < <(yq '.cleanupResources[]' default_config.yaml)
        for RESOURCE in "${CLEANUP_RESOURCES[@]}"; do
            delete_resources_with_prefix "$RESOURCE"
        done

  checkout-to-mpo:
    deps:
      - d8
    cmds:
      - |
        if [ -z "$v12n_tag" ]; then
          echo "Error: v12n_tag is not set."
          exit 1
        fi
        DECKHOUSE_READY_STATUS=$(kubectl get po -n d8-system -l app=deckhouse -o json | jq -r '.items[0].status.conditions[] | select(.type=="ContainersReady") | .status')
        if [ "$DECKHOUSE_READY_STATUS" != "True" ]; then
          echo "Error: Deckhouse is not ready."
          exit 1
        fi

        d8 k patch mpo virtualization --type merge -p "{\"spec\":{\"imageTag\":\"$v12n_tag\"}}"
        images_hash=$(crane export "dev-registry.deckhouse.io/sys/deckhouse-oss/modules/virtualization:$v12n_tag" - | tar -Oxf - images_digests.json)

        v12n_pods=$(kubectl -n d8-virtualization get pods -o json | jq -c)

        audit_status=$(kubectl get mc virtualization -o=jsonpath='{.spec.settings.audit.enabled}')
        audit_image_skip=$(if [ -z $audit_status ] || [ $audit_status == "false" ]; then echo "true";else echo "false";fi)

        retry_count=0
        max_retries=120
        sleep_interval=5

        if [ $audit_image_skip == "true" ]; then
          SKIP_IMAGES=("virtualizationAudit")
        fi

        is_skipped_image() {
          local img="$1"
          if [ ${#img} -eq 0 ]; then return 1 ;fi

          for skip in "${SKIP_IMAGES[@]}"; do
            if [[ "$img" == "$skip" ]]; then
              return 0  # image found in skip list
            fi
          done
          return 1  # image not in skip list
        }

        while true; do
          all_hashes_found=true

          # Fetch current pods information
          v12n_pods=$(kubectl -n d8-virtualization get pods -o json | jq -c)

          # Process each image entry
          while IFS= read -r image_entry; do
            image=$(echo "$image_entry" | jq -r '.key')
            hash=$(echo "$image_entry" | jq -r '.value')

            if [[ "${image,,}" =~ (libguestfs|predeletehook) ]]; then
              continue
            fi

            if is_skipped_image "$image"; then
              echo "- â­ï¸  Skipping $image"
              continue
            fi

            if echo "$v12n_pods" | grep -q "$hash"; then
              echo "- âœ… $image $hash"
            else
              echo "- ðŸŸ¥ $image $hash"
              all_hashes_found=false
            fi
          done < <(echo "$images_hash" | jq -c '. | to_entries | sort_by(.key)[]')

          # If all hashes are found, break the loop
          if [ "$all_hashes_found" = true ]; then
            echo "All image hashes found in pods."
            break
          fi

          retry_count=$((retry_count + 1))
          echo "Some hashes are missing, rechecking... Attempt: $retry_count"

          # Check if the retry limit has been reached
          if [ "$retry_count" -ge "$max_retries" ]; then
            echo "Error: Timeout reached after $((retry_count * sleep_interval)) seconds. Some image hashes are still missing."
            exit 1
          fi
          # Wait for the specified interval before retrying
          sleep "$sleep_interval"
        done

  _ensure:golangci-lint:
    desc: "Ensure golangci-lint is available"
    internal: true
    cmds:
      - |
        echo -e >&2 "Please install golangci-lint https://golangci-lint.run/usage/install/"
        exit 1
    status:
      - |
        [ -f ./golangci-lint ] || which golangci-lint

  lint:go:
    desc: "Run golangci-lint"
    deps:
      - _ensure:golangci-lint
    cmds:
      - |
        golangci-lint run --sort-results
