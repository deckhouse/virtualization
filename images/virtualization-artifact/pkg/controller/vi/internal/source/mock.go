// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package source

import (
	"context"
	"github.com/deckhouse/virtualization-controller/pkg/common/datasource"
	"github.com/deckhouse/virtualization-controller/pkg/controller/importer"
	"github.com/deckhouse/virtualization-controller/pkg/controller/service"
	"github.com/deckhouse/virtualization-controller/pkg/controller/supplements"
	"github.com/deckhouse/virtualization-controller/pkg/controller/uploader"
	"github.com/deckhouse/virtualization/api/core/v1alpha2"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	"sync"
)

// Ensure, that ImporterMock does implement Importer.
// If this is not the case, regenerate this file with moq.
var _ Importer = &ImporterMock{}

// ImporterMock is a mock implementation of Importer.
//
//	func TestSomethingThatUsesImporter(t *testing.T) {
//
//		// make and configure a mocked Importer
//		mockedImporter := &ImporterMock{
//			CleanUpFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetPodFunc: func(ctx context.Context, sup supplements.Generator) (*corev1.Pod, error) {
//				panic("mock out the GetPod method")
//			},
//			GetPodSettingsWithPVCFunc: func(ownerReference *metav1.OwnerReference, generator supplements.Generator, s1 string, s2 string) *importer.PodSettings {
//				panic("mock out the GetPodSettingsWithPVC method")
//			},
//			ProtectFunc: func(ctx context.Context, pod *corev1.Pod, sup supplements.Generator) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, settings *importer.Settings, obj client.Object, sup supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//			StartWithPodSettingFunc: func(contextMoqParam context.Context, settings *importer.Settings, generator supplements.Generator, cABundle *datasource.CABundle, podSettings *importer.PodSettings, options ...service.Option) error {
//				panic("mock out the StartWithPodSetting method")
//			},
//			UnprotectFunc: func(ctx context.Context, pod *corev1.Pod, sup supplements.Generator) error {
//				panic("mock out the Unprotect method")
//			},
//		}
//
//		// use mockedImporter in code that requires Importer
//		// and then make assertions.
//
//	}
type ImporterMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// GetPodFunc mocks the GetPod method.
	GetPodFunc func(ctx context.Context, sup supplements.Generator) (*corev1.Pod, error)

	// GetPodSettingsWithPVCFunc mocks the GetPodSettingsWithPVC method.
	GetPodSettingsWithPVCFunc func(ownerReference *metav1.OwnerReference, generator supplements.Generator, s1 string, s2 string) *importer.PodSettings

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, pod *corev1.Pod, sup supplements.Generator) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, settings *importer.Settings, obj client.Object, sup supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error

	// StartWithPodSettingFunc mocks the StartWithPodSetting method.
	StartWithPodSettingFunc func(contextMoqParam context.Context, settings *importer.Settings, generator supplements.Generator, cABundle *datasource.CABundle, podSettings *importer.PodSettings, options ...service.Option) error

	// UnprotectFunc mocks the Unprotect method.
	UnprotectFunc func(ctx context.Context, pod *corev1.Pod, sup supplements.Generator) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetPod holds details about calls to the GetPod method.
		GetPod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetPodSettingsWithPVC holds details about calls to the GetPodSettingsWithPVC method.
		GetPodSettingsWithPVC []struct {
			// OwnerReference is the ownerReference argument value.
			OwnerReference *metav1.OwnerReference
			// Generator is the generator argument value.
			Generator supplements.Generator
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *importer.Settings
			// Obj is the obj argument value.
			Obj client.Object
			// Sup is the sup argument value.
			Sup supplements.Generator
			// CaBundle is the caBundle argument value.
			CaBundle *datasource.CABundle
			// Opts is the opts argument value.
			Opts []service.Option
		}
		// StartWithPodSetting holds details about calls to the StartWithPodSetting method.
		StartWithPodSetting []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Settings is the settings argument value.
			Settings *importer.Settings
			// Generator is the generator argument value.
			Generator supplements.Generator
			// CABundle is the cABundle argument value.
			CABundle *datasource.CABundle
			// PodSettings is the podSettings argument value.
			PodSettings *importer.PodSettings
			// Options is the options argument value.
			Options []service.Option
		}
		// Unprotect holds details about calls to the Unprotect method.
		Unprotect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
	}
	lockCleanUp               sync.RWMutex
	lockCleanUpSupplements    sync.RWMutex
	lockGetPod                sync.RWMutex
	lockGetPodSettingsWithPVC sync.RWMutex
	lockProtect               sync.RWMutex
	lockStart                 sync.RWMutex
	lockStartWithPodSetting   sync.RWMutex
	lockUnprotect             sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *ImporterMock) CleanUp(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("ImporterMock.CleanUpFunc: method is nil but Importer.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedImporter.CleanUpCalls())
func (mock *ImporterMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *ImporterMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("ImporterMock.CleanUpSupplementsFunc: method is nil but Importer.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedImporter.CleanUpSupplementsCalls())
func (mock *ImporterMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetPod calls GetPodFunc.
func (mock *ImporterMock) GetPod(ctx context.Context, sup supplements.Generator) (*corev1.Pod, error) {
	if mock.GetPodFunc == nil {
		panic("ImporterMock.GetPodFunc: method is nil but Importer.GetPod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetPod.Lock()
	mock.calls.GetPod = append(mock.calls.GetPod, callInfo)
	mock.lockGetPod.Unlock()
	return mock.GetPodFunc(ctx, sup)
}

// GetPodCalls gets all the calls that were made to GetPod.
// Check the length with:
//
//	len(mockedImporter.GetPodCalls())
func (mock *ImporterMock) GetPodCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockGetPod.RLock()
	calls = mock.calls.GetPod
	mock.lockGetPod.RUnlock()
	return calls
}

// GetPodSettingsWithPVC calls GetPodSettingsWithPVCFunc.
func (mock *ImporterMock) GetPodSettingsWithPVC(ownerReference *metav1.OwnerReference, generator supplements.Generator, s1 string, s2 string) *importer.PodSettings {
	if mock.GetPodSettingsWithPVCFunc == nil {
		panic("ImporterMock.GetPodSettingsWithPVCFunc: method is nil but Importer.GetPodSettingsWithPVC was just called")
	}
	callInfo := struct {
		OwnerReference *metav1.OwnerReference
		Generator      supplements.Generator
		S1             string
		S2             string
	}{
		OwnerReference: ownerReference,
		Generator:      generator,
		S1:             s1,
		S2:             s2,
	}
	mock.lockGetPodSettingsWithPVC.Lock()
	mock.calls.GetPodSettingsWithPVC = append(mock.calls.GetPodSettingsWithPVC, callInfo)
	mock.lockGetPodSettingsWithPVC.Unlock()
	return mock.GetPodSettingsWithPVCFunc(ownerReference, generator, s1, s2)
}

// GetPodSettingsWithPVCCalls gets all the calls that were made to GetPodSettingsWithPVC.
// Check the length with:
//
//	len(mockedImporter.GetPodSettingsWithPVCCalls())
func (mock *ImporterMock) GetPodSettingsWithPVCCalls() []struct {
	OwnerReference *metav1.OwnerReference
	Generator      supplements.Generator
	S1             string
	S2             string
} {
	var calls []struct {
		OwnerReference *metav1.OwnerReference
		Generator      supplements.Generator
		S1             string
		S2             string
	}
	mock.lockGetPodSettingsWithPVC.RLock()
	calls = mock.calls.GetPodSettingsWithPVC
	mock.lockGetPodSettingsWithPVC.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *ImporterMock) Protect(ctx context.Context, pod *corev1.Pod, sup supplements.Generator) error {
	if mock.ProtectFunc == nil {
		panic("ImporterMock.ProtectFunc: method is nil but Importer.Protect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Pod: pod,
		Sup: sup,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, pod, sup)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedImporter.ProtectCalls())
func (mock *ImporterMock) ProtectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
		Sup supplements.Generator
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *ImporterMock) Start(ctx context.Context, settings *importer.Settings, obj client.Object, sup supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("ImporterMock.StartFunc: method is nil but Importer.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Settings *importer.Settings
		Obj      client.Object
		Sup      supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}{
		Ctx:      ctx,
		Settings: settings,
		Obj:      obj,
		Sup:      sup,
		CaBundle: caBundle,
		Opts:     opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, settings, obj, sup, caBundle, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedImporter.StartCalls())
func (mock *ImporterMock) StartCalls() []struct {
	Ctx      context.Context
	Settings *importer.Settings
	Obj      client.Object
	Sup      supplements.Generator
	CaBundle *datasource.CABundle
	Opts     []service.Option
} {
	var calls []struct {
		Ctx      context.Context
		Settings *importer.Settings
		Obj      client.Object
		Sup      supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// StartWithPodSetting calls StartWithPodSettingFunc.
func (mock *ImporterMock) StartWithPodSetting(contextMoqParam context.Context, settings *importer.Settings, generator supplements.Generator, cABundle *datasource.CABundle, podSettings *importer.PodSettings, options ...service.Option) error {
	if mock.StartWithPodSettingFunc == nil {
		panic("ImporterMock.StartWithPodSettingFunc: method is nil but Importer.StartWithPodSetting was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Settings        *importer.Settings
		Generator       supplements.Generator
		CABundle        *datasource.CABundle
		PodSettings     *importer.PodSettings
		Options         []service.Option
	}{
		ContextMoqParam: contextMoqParam,
		Settings:        settings,
		Generator:       generator,
		CABundle:        cABundle,
		PodSettings:     podSettings,
		Options:         options,
	}
	mock.lockStartWithPodSetting.Lock()
	mock.calls.StartWithPodSetting = append(mock.calls.StartWithPodSetting, callInfo)
	mock.lockStartWithPodSetting.Unlock()
	return mock.StartWithPodSettingFunc(contextMoqParam, settings, generator, cABundle, podSettings, options...)
}

// StartWithPodSettingCalls gets all the calls that were made to StartWithPodSetting.
// Check the length with:
//
//	len(mockedImporter.StartWithPodSettingCalls())
func (mock *ImporterMock) StartWithPodSettingCalls() []struct {
	ContextMoqParam context.Context
	Settings        *importer.Settings
	Generator       supplements.Generator
	CABundle        *datasource.CABundle
	PodSettings     *importer.PodSettings
	Options         []service.Option
} {
	var calls []struct {
		ContextMoqParam context.Context
		Settings        *importer.Settings
		Generator       supplements.Generator
		CABundle        *datasource.CABundle
		PodSettings     *importer.PodSettings
		Options         []service.Option
	}
	mock.lockStartWithPodSetting.RLock()
	calls = mock.calls.StartWithPodSetting
	mock.lockStartWithPodSetting.RUnlock()
	return calls
}

// Unprotect calls UnprotectFunc.
func (mock *ImporterMock) Unprotect(ctx context.Context, pod *corev1.Pod, sup supplements.Generator) error {
	if mock.UnprotectFunc == nil {
		panic("ImporterMock.UnprotectFunc: method is nil but Importer.Unprotect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Pod: pod,
		Sup: sup,
	}
	mock.lockUnprotect.Lock()
	mock.calls.Unprotect = append(mock.calls.Unprotect, callInfo)
	mock.lockUnprotect.Unlock()
	return mock.UnprotectFunc(ctx, pod, sup)
}

// UnprotectCalls gets all the calls that were made to Unprotect.
// Check the length with:
//
//	len(mockedImporter.UnprotectCalls())
func (mock *ImporterMock) UnprotectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
		Sup supplements.Generator
	}
	mock.lockUnprotect.RLock()
	calls = mock.calls.Unprotect
	mock.lockUnprotect.RUnlock()
	return calls
}

// Ensure, that UploaderMock does implement Uploader.
// If this is not the case, regenerate this file with moq.
var _ Uploader = &UploaderMock{}

// UploaderMock is a mock implementation of Uploader.
//
//	func TestSomethingThatUsesUploader(t *testing.T) {
//
//		// make and configure a mocked Uploader
//		mockedUploader := &UploaderMock{
//			CleanUpFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetExternalURLFunc: func(ctx context.Context, ing *netv1.Ingress) string {
//				panic("mock out the GetExternalURL method")
//			},
//			GetInClusterURLFunc: func(ctx context.Context, svc *corev1.Service) string {
//				panic("mock out the GetInClusterURL method")
//			},
//			GetIngressFunc: func(ctx context.Context, sup supplements.Generator) (*netv1.Ingress, error) {
//				panic("mock out the GetIngress method")
//			},
//			GetPodFunc: func(ctx context.Context, sup supplements.Generator) (*corev1.Pod, error) {
//				panic("mock out the GetPod method")
//			},
//			GetServiceFunc: func(ctx context.Context, sup supplements.Generator) (*corev1.Service, error) {
//				panic("mock out the GetService method")
//			},
//			ProtectFunc: func(ctx context.Context, sup supplements.Generator, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, settings *uploader.Settings, obj client.Object, sup supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//			UnprotectFunc: func(ctx context.Context, sup supplements.Generator, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
//				panic("mock out the Unprotect method")
//			},
//		}
//
//		// use mockedUploader in code that requires Uploader
//		// and then make assertions.
//
//	}
type UploaderMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// GetExternalURLFunc mocks the GetExternalURL method.
	GetExternalURLFunc func(ctx context.Context, ing *netv1.Ingress) string

	// GetInClusterURLFunc mocks the GetInClusterURL method.
	GetInClusterURLFunc func(ctx context.Context, svc *corev1.Service) string

	// GetIngressFunc mocks the GetIngress method.
	GetIngressFunc func(ctx context.Context, sup supplements.Generator) (*netv1.Ingress, error)

	// GetPodFunc mocks the GetPod method.
	GetPodFunc func(ctx context.Context, sup supplements.Generator) (*corev1.Pod, error)

	// GetServiceFunc mocks the GetService method.
	GetServiceFunc func(ctx context.Context, sup supplements.Generator) (*corev1.Service, error)

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, sup supplements.Generator, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, settings *uploader.Settings, obj client.Object, sup supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error

	// UnprotectFunc mocks the Unprotect method.
	UnprotectFunc func(ctx context.Context, sup supplements.Generator, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetExternalURL holds details about calls to the GetExternalURL method.
		GetExternalURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
		// GetInClusterURL holds details about calls to the GetInClusterURL method.
		GetInClusterURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Svc is the svc argument value.
			Svc *corev1.Service
		}
		// GetIngress holds details about calls to the GetIngress method.
		GetIngress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetPod holds details about calls to the GetPod method.
		GetPod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetService holds details about calls to the GetService method.
		GetService []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *uploader.Settings
			// Obj is the obj argument value.
			Obj client.Object
			// Sup is the sup argument value.
			Sup supplements.Generator
			// CaBundle is the caBundle argument value.
			CaBundle *datasource.CABundle
			// Opts is the opts argument value.
			Opts []service.Option
		}
		// Unprotect holds details about calls to the Unprotect method.
		Unprotect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
	}
	lockCleanUp            sync.RWMutex
	lockCleanUpSupplements sync.RWMutex
	lockGetExternalURL     sync.RWMutex
	lockGetInClusterURL    sync.RWMutex
	lockGetIngress         sync.RWMutex
	lockGetPod             sync.RWMutex
	lockGetService         sync.RWMutex
	lockProtect            sync.RWMutex
	lockStart              sync.RWMutex
	lockUnprotect          sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *UploaderMock) CleanUp(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("UploaderMock.CleanUpFunc: method is nil but Uploader.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedUploader.CleanUpCalls())
func (mock *UploaderMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *UploaderMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("UploaderMock.CleanUpSupplementsFunc: method is nil but Uploader.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedUploader.CleanUpSupplementsCalls())
func (mock *UploaderMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetExternalURL calls GetExternalURLFunc.
func (mock *UploaderMock) GetExternalURL(ctx context.Context, ing *netv1.Ingress) string {
	if mock.GetExternalURLFunc == nil {
		panic("UploaderMock.GetExternalURLFunc: method is nil but Uploader.GetExternalURL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Ing: ing,
	}
	mock.lockGetExternalURL.Lock()
	mock.calls.GetExternalURL = append(mock.calls.GetExternalURL, callInfo)
	mock.lockGetExternalURL.Unlock()
	return mock.GetExternalURLFunc(ctx, ing)
}

// GetExternalURLCalls gets all the calls that were made to GetExternalURL.
// Check the length with:
//
//	len(mockedUploader.GetExternalURLCalls())
func (mock *UploaderMock) GetExternalURLCalls() []struct {
	Ctx context.Context
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Ing *netv1.Ingress
	}
	mock.lockGetExternalURL.RLock()
	calls = mock.calls.GetExternalURL
	mock.lockGetExternalURL.RUnlock()
	return calls
}

// GetInClusterURL calls GetInClusterURLFunc.
func (mock *UploaderMock) GetInClusterURL(ctx context.Context, svc *corev1.Service) string {
	if mock.GetInClusterURLFunc == nil {
		panic("UploaderMock.GetInClusterURLFunc: method is nil but Uploader.GetInClusterURL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Svc *corev1.Service
	}{
		Ctx: ctx,
		Svc: svc,
	}
	mock.lockGetInClusterURL.Lock()
	mock.calls.GetInClusterURL = append(mock.calls.GetInClusterURL, callInfo)
	mock.lockGetInClusterURL.Unlock()
	return mock.GetInClusterURLFunc(ctx, svc)
}

// GetInClusterURLCalls gets all the calls that were made to GetInClusterURL.
// Check the length with:
//
//	len(mockedUploader.GetInClusterURLCalls())
func (mock *UploaderMock) GetInClusterURLCalls() []struct {
	Ctx context.Context
	Svc *corev1.Service
} {
	var calls []struct {
		Ctx context.Context
		Svc *corev1.Service
	}
	mock.lockGetInClusterURL.RLock()
	calls = mock.calls.GetInClusterURL
	mock.lockGetInClusterURL.RUnlock()
	return calls
}

// GetIngress calls GetIngressFunc.
func (mock *UploaderMock) GetIngress(ctx context.Context, sup supplements.Generator) (*netv1.Ingress, error) {
	if mock.GetIngressFunc == nil {
		panic("UploaderMock.GetIngressFunc: method is nil but Uploader.GetIngress was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetIngress.Lock()
	mock.calls.GetIngress = append(mock.calls.GetIngress, callInfo)
	mock.lockGetIngress.Unlock()
	return mock.GetIngressFunc(ctx, sup)
}

// GetIngressCalls gets all the calls that were made to GetIngress.
// Check the length with:
//
//	len(mockedUploader.GetIngressCalls())
func (mock *UploaderMock) GetIngressCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockGetIngress.RLock()
	calls = mock.calls.GetIngress
	mock.lockGetIngress.RUnlock()
	return calls
}

// GetPod calls GetPodFunc.
func (mock *UploaderMock) GetPod(ctx context.Context, sup supplements.Generator) (*corev1.Pod, error) {
	if mock.GetPodFunc == nil {
		panic("UploaderMock.GetPodFunc: method is nil but Uploader.GetPod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetPod.Lock()
	mock.calls.GetPod = append(mock.calls.GetPod, callInfo)
	mock.lockGetPod.Unlock()
	return mock.GetPodFunc(ctx, sup)
}

// GetPodCalls gets all the calls that were made to GetPod.
// Check the length with:
//
//	len(mockedUploader.GetPodCalls())
func (mock *UploaderMock) GetPodCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockGetPod.RLock()
	calls = mock.calls.GetPod
	mock.lockGetPod.RUnlock()
	return calls
}

// GetService calls GetServiceFunc.
func (mock *UploaderMock) GetService(ctx context.Context, sup supplements.Generator) (*corev1.Service, error) {
	if mock.GetServiceFunc == nil {
		panic("UploaderMock.GetServiceFunc: method is nil but Uploader.GetService was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetService.Lock()
	mock.calls.GetService = append(mock.calls.GetService, callInfo)
	mock.lockGetService.Unlock()
	return mock.GetServiceFunc(ctx, sup)
}

// GetServiceCalls gets all the calls that were made to GetService.
// Check the length with:
//
//	len(mockedUploader.GetServiceCalls())
func (mock *UploaderMock) GetServiceCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockGetService.RLock()
	calls = mock.calls.GetService
	mock.lockGetService.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *UploaderMock) Protect(ctx context.Context, sup supplements.Generator, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
	if mock.ProtectFunc == nil {
		panic("UploaderMock.ProtectFunc: method is nil but Uploader.Protect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Sup: sup,
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, sup, pod, svc, ing)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedUploader.ProtectCalls())
func (mock *UploaderMock) ProtectCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *UploaderMock) Start(ctx context.Context, settings *uploader.Settings, obj client.Object, sup supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("UploaderMock.StartFunc: method is nil but Uploader.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Settings *uploader.Settings
		Obj      client.Object
		Sup      supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}{
		Ctx:      ctx,
		Settings: settings,
		Obj:      obj,
		Sup:      sup,
		CaBundle: caBundle,
		Opts:     opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, settings, obj, sup, caBundle, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedUploader.StartCalls())
func (mock *UploaderMock) StartCalls() []struct {
	Ctx      context.Context
	Settings *uploader.Settings
	Obj      client.Object
	Sup      supplements.Generator
	CaBundle *datasource.CABundle
	Opts     []service.Option
} {
	var calls []struct {
		Ctx      context.Context
		Settings *uploader.Settings
		Obj      client.Object
		Sup      supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Unprotect calls UnprotectFunc.
func (mock *UploaderMock) Unprotect(ctx context.Context, sup supplements.Generator, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
	if mock.UnprotectFunc == nil {
		panic("UploaderMock.UnprotectFunc: method is nil but Uploader.Unprotect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Sup: sup,
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockUnprotect.Lock()
	mock.calls.Unprotect = append(mock.calls.Unprotect, callInfo)
	mock.lockUnprotect.Unlock()
	return mock.UnprotectFunc(ctx, sup, pod, svc, ing)
}

// UnprotectCalls gets all the calls that were made to Unprotect.
// Check the length with:
//
//	len(mockedUploader.UnprotectCalls())
func (mock *UploaderMock) UnprotectCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockUnprotect.RLock()
	calls = mock.calls.Unprotect
	mock.lockUnprotect.RUnlock()
	return calls
}

// Ensure, that StatMock does implement Stat.
// If this is not the case, regenerate this file with moq.
var _ Stat = &StatMock{}

// StatMock is a mock implementation of Stat.
//
//	func TestSomethingThatUsesStat(t *testing.T) {
//
//		// make and configure a mocked Stat
//		mockedStat := &StatMock{
//			CheckPodFunc: func(pod *corev1.Pod) error {
//				panic("mock out the CheckPod method")
//			},
//			GetCDROMFunc: func(pod *corev1.Pod) bool {
//				panic("mock out the GetCDROM method")
//			},
//			GetDVCRImageNameFunc: func(pod *corev1.Pod) string {
//				panic("mock out the GetDVCRImageName method")
//			},
//			GetDownloadSpeedFunc: func(ownerUID types.UID, pod *corev1.Pod) *v1alpha2.StatusSpeed {
//				panic("mock out the GetDownloadSpeed method")
//			},
//			GetFormatFunc: func(pod *corev1.Pod) string {
//				panic("mock out the GetFormat method")
//			},
//			GetProgressFunc: func(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string {
//				panic("mock out the GetProgress method")
//			},
//			GetSizeFunc: func(pod *corev1.Pod) v1alpha2.ImageStatusSize {
//				panic("mock out the GetSize method")
//			},
//			IsUploadStartedFunc: func(ownerUID types.UID, pod *corev1.Pod) bool {
//				panic("mock out the IsUploadStarted method")
//			},
//			IsUploaderReadyFunc: func(pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) bool {
//				panic("mock out the IsUploaderReady method")
//			},
//		}
//
//		// use mockedStat in code that requires Stat
//		// and then make assertions.
//
//	}
type StatMock struct {
	// CheckPodFunc mocks the CheckPod method.
	CheckPodFunc func(pod *corev1.Pod) error

	// GetCDROMFunc mocks the GetCDROM method.
	GetCDROMFunc func(pod *corev1.Pod) bool

	// GetDVCRImageNameFunc mocks the GetDVCRImageName method.
	GetDVCRImageNameFunc func(pod *corev1.Pod) string

	// GetDownloadSpeedFunc mocks the GetDownloadSpeed method.
	GetDownloadSpeedFunc func(ownerUID types.UID, pod *corev1.Pod) *v1alpha2.StatusSpeed

	// GetFormatFunc mocks the GetFormat method.
	GetFormatFunc func(pod *corev1.Pod) string

	// GetProgressFunc mocks the GetProgress method.
	GetProgressFunc func(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string

	// GetSizeFunc mocks the GetSize method.
	GetSizeFunc func(pod *corev1.Pod) v1alpha2.ImageStatusSize

	// IsUploadStartedFunc mocks the IsUploadStarted method.
	IsUploadStartedFunc func(ownerUID types.UID, pod *corev1.Pod) bool

	// IsUploaderReadyFunc mocks the IsUploaderReady method.
	IsUploaderReadyFunc func(pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) bool

	// calls tracks calls to the methods.
	calls struct {
		// CheckPod holds details about calls to the CheckPod method.
		CheckPod []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetCDROM holds details about calls to the GetCDROM method.
		GetCDROM []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetDVCRImageName holds details about calls to the GetDVCRImageName method.
		GetDVCRImageName []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetDownloadSpeed holds details about calls to the GetDownloadSpeed method.
		GetDownloadSpeed []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetFormat holds details about calls to the GetFormat method.
		GetFormat []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetProgress holds details about calls to the GetProgress method.
		GetProgress []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// PrevProgress is the prevProgress argument value.
			PrevProgress string
			// Opts is the opts argument value.
			Opts []service.GetProgressOption
		}
		// GetSize holds details about calls to the GetSize method.
		GetSize []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// IsUploadStarted holds details about calls to the IsUploadStarted method.
		IsUploadStarted []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// IsUploaderReady holds details about calls to the IsUploaderReady method.
		IsUploaderReady []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
	}
	lockCheckPod         sync.RWMutex
	lockGetCDROM         sync.RWMutex
	lockGetDVCRImageName sync.RWMutex
	lockGetDownloadSpeed sync.RWMutex
	lockGetFormat        sync.RWMutex
	lockGetProgress      sync.RWMutex
	lockGetSize          sync.RWMutex
	lockIsUploadStarted  sync.RWMutex
	lockIsUploaderReady  sync.RWMutex
}

// CheckPod calls CheckPodFunc.
func (mock *StatMock) CheckPod(pod *corev1.Pod) error {
	if mock.CheckPodFunc == nil {
		panic("StatMock.CheckPodFunc: method is nil but Stat.CheckPod was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockCheckPod.Lock()
	mock.calls.CheckPod = append(mock.calls.CheckPod, callInfo)
	mock.lockCheckPod.Unlock()
	return mock.CheckPodFunc(pod)
}

// CheckPodCalls gets all the calls that were made to CheckPod.
// Check the length with:
//
//	len(mockedStat.CheckPodCalls())
func (mock *StatMock) CheckPodCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockCheckPod.RLock()
	calls = mock.calls.CheckPod
	mock.lockCheckPod.RUnlock()
	return calls
}

// GetCDROM calls GetCDROMFunc.
func (mock *StatMock) GetCDROM(pod *corev1.Pod) bool {
	if mock.GetCDROMFunc == nil {
		panic("StatMock.GetCDROMFunc: method is nil but Stat.GetCDROM was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetCDROM.Lock()
	mock.calls.GetCDROM = append(mock.calls.GetCDROM, callInfo)
	mock.lockGetCDROM.Unlock()
	return mock.GetCDROMFunc(pod)
}

// GetCDROMCalls gets all the calls that were made to GetCDROM.
// Check the length with:
//
//	len(mockedStat.GetCDROMCalls())
func (mock *StatMock) GetCDROMCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetCDROM.RLock()
	calls = mock.calls.GetCDROM
	mock.lockGetCDROM.RUnlock()
	return calls
}

// GetDVCRImageName calls GetDVCRImageNameFunc.
func (mock *StatMock) GetDVCRImageName(pod *corev1.Pod) string {
	if mock.GetDVCRImageNameFunc == nil {
		panic("StatMock.GetDVCRImageNameFunc: method is nil but Stat.GetDVCRImageName was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetDVCRImageName.Lock()
	mock.calls.GetDVCRImageName = append(mock.calls.GetDVCRImageName, callInfo)
	mock.lockGetDVCRImageName.Unlock()
	return mock.GetDVCRImageNameFunc(pod)
}

// GetDVCRImageNameCalls gets all the calls that were made to GetDVCRImageName.
// Check the length with:
//
//	len(mockedStat.GetDVCRImageNameCalls())
func (mock *StatMock) GetDVCRImageNameCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetDVCRImageName.RLock()
	calls = mock.calls.GetDVCRImageName
	mock.lockGetDVCRImageName.RUnlock()
	return calls
}

// GetDownloadSpeed calls GetDownloadSpeedFunc.
func (mock *StatMock) GetDownloadSpeed(ownerUID types.UID, pod *corev1.Pod) *v1alpha2.StatusSpeed {
	if mock.GetDownloadSpeedFunc == nil {
		panic("StatMock.GetDownloadSpeedFunc: method is nil but Stat.GetDownloadSpeed was just called")
	}
	callInfo := struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}{
		OwnerUID: ownerUID,
		Pod:      pod,
	}
	mock.lockGetDownloadSpeed.Lock()
	mock.calls.GetDownloadSpeed = append(mock.calls.GetDownloadSpeed, callInfo)
	mock.lockGetDownloadSpeed.Unlock()
	return mock.GetDownloadSpeedFunc(ownerUID, pod)
}

// GetDownloadSpeedCalls gets all the calls that were made to GetDownloadSpeed.
// Check the length with:
//
//	len(mockedStat.GetDownloadSpeedCalls())
func (mock *StatMock) GetDownloadSpeedCalls() []struct {
	OwnerUID types.UID
	Pod      *corev1.Pod
} {
	var calls []struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}
	mock.lockGetDownloadSpeed.RLock()
	calls = mock.calls.GetDownloadSpeed
	mock.lockGetDownloadSpeed.RUnlock()
	return calls
}

// GetFormat calls GetFormatFunc.
func (mock *StatMock) GetFormat(pod *corev1.Pod) string {
	if mock.GetFormatFunc == nil {
		panic("StatMock.GetFormatFunc: method is nil but Stat.GetFormat was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetFormat.Lock()
	mock.calls.GetFormat = append(mock.calls.GetFormat, callInfo)
	mock.lockGetFormat.Unlock()
	return mock.GetFormatFunc(pod)
}

// GetFormatCalls gets all the calls that were made to GetFormat.
// Check the length with:
//
//	len(mockedStat.GetFormatCalls())
func (mock *StatMock) GetFormatCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetFormat.RLock()
	calls = mock.calls.GetFormat
	mock.lockGetFormat.RUnlock()
	return calls
}

// GetProgress calls GetProgressFunc.
func (mock *StatMock) GetProgress(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string {
	if mock.GetProgressFunc == nil {
		panic("StatMock.GetProgressFunc: method is nil but Stat.GetProgress was just called")
	}
	callInfo := struct {
		OwnerUID     types.UID
		Pod          *corev1.Pod
		PrevProgress string
		Opts         []service.GetProgressOption
	}{
		OwnerUID:     ownerUID,
		Pod:          pod,
		PrevProgress: prevProgress,
		Opts:         opts,
	}
	mock.lockGetProgress.Lock()
	mock.calls.GetProgress = append(mock.calls.GetProgress, callInfo)
	mock.lockGetProgress.Unlock()
	return mock.GetProgressFunc(ownerUID, pod, prevProgress, opts...)
}

// GetProgressCalls gets all the calls that were made to GetProgress.
// Check the length with:
//
//	len(mockedStat.GetProgressCalls())
func (mock *StatMock) GetProgressCalls() []struct {
	OwnerUID     types.UID
	Pod          *corev1.Pod
	PrevProgress string
	Opts         []service.GetProgressOption
} {
	var calls []struct {
		OwnerUID     types.UID
		Pod          *corev1.Pod
		PrevProgress string
		Opts         []service.GetProgressOption
	}
	mock.lockGetProgress.RLock()
	calls = mock.calls.GetProgress
	mock.lockGetProgress.RUnlock()
	return calls
}

// GetSize calls GetSizeFunc.
func (mock *StatMock) GetSize(pod *corev1.Pod) v1alpha2.ImageStatusSize {
	if mock.GetSizeFunc == nil {
		panic("StatMock.GetSizeFunc: method is nil but Stat.GetSize was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetSize.Lock()
	mock.calls.GetSize = append(mock.calls.GetSize, callInfo)
	mock.lockGetSize.Unlock()
	return mock.GetSizeFunc(pod)
}

// GetSizeCalls gets all the calls that were made to GetSize.
// Check the length with:
//
//	len(mockedStat.GetSizeCalls())
func (mock *StatMock) GetSizeCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetSize.RLock()
	calls = mock.calls.GetSize
	mock.lockGetSize.RUnlock()
	return calls
}

// IsUploadStarted calls IsUploadStartedFunc.
func (mock *StatMock) IsUploadStarted(ownerUID types.UID, pod *corev1.Pod) bool {
	if mock.IsUploadStartedFunc == nil {
		panic("StatMock.IsUploadStartedFunc: method is nil but Stat.IsUploadStarted was just called")
	}
	callInfo := struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}{
		OwnerUID: ownerUID,
		Pod:      pod,
	}
	mock.lockIsUploadStarted.Lock()
	mock.calls.IsUploadStarted = append(mock.calls.IsUploadStarted, callInfo)
	mock.lockIsUploadStarted.Unlock()
	return mock.IsUploadStartedFunc(ownerUID, pod)
}

// IsUploadStartedCalls gets all the calls that were made to IsUploadStarted.
// Check the length with:
//
//	len(mockedStat.IsUploadStartedCalls())
func (mock *StatMock) IsUploadStartedCalls() []struct {
	OwnerUID types.UID
	Pod      *corev1.Pod
} {
	var calls []struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}
	mock.lockIsUploadStarted.RLock()
	calls = mock.calls.IsUploadStarted
	mock.lockIsUploadStarted.RUnlock()
	return calls
}

// IsUploaderReady calls IsUploaderReadyFunc.
func (mock *StatMock) IsUploaderReady(pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) bool {
	if mock.IsUploaderReadyFunc == nil {
		panic("StatMock.IsUploaderReadyFunc: method is nil but Stat.IsUploaderReady was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockIsUploaderReady.Lock()
	mock.calls.IsUploaderReady = append(mock.calls.IsUploaderReady, callInfo)
	mock.lockIsUploaderReady.Unlock()
	return mock.IsUploaderReadyFunc(pod, svc, ing)
}

// IsUploaderReadyCalls gets all the calls that were made to IsUploaderReady.
// Check the length with:
//
//	len(mockedStat.IsUploaderReadyCalls())
func (mock *StatMock) IsUploaderReadyCalls() []struct {
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockIsUploaderReady.RLock()
	calls = mock.calls.IsUploaderReady
	mock.lockIsUploaderReady.RUnlock()
	return calls
}

// Ensure, that BounderMock does implement Bounder.
// If this is not the case, regenerate this file with moq.
var _ Bounder = &BounderMock{}

// BounderMock is a mock implementation of Bounder.
//
//	func TestSomethingThatUsesBounder(t *testing.T) {
//
//		// make and configure a mocked Bounder
//		mockedBounder := &BounderMock{
//			CleanUpFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			StartFunc: func(ctx context.Context, ownerRef *metav1.OwnerReference, sup supplements.Generator, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//		}
//
//		// use mockedBounder in code that requires Bounder
//		// and then make assertions.
//
//	}
type BounderMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, ownerRef *metav1.OwnerReference, sup supplements.Generator, opts ...service.Option) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerRef is the ownerRef argument value.
			OwnerRef *metav1.OwnerReference
			// Sup is the sup argument value.
			Sup supplements.Generator
			// Opts is the opts argument value.
			Opts []service.Option
		}
	}
	lockCleanUp            sync.RWMutex
	lockCleanUpSupplements sync.RWMutex
	lockStart              sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *BounderMock) CleanUp(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("BounderMock.CleanUpFunc: method is nil but Bounder.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedBounder.CleanUpCalls())
func (mock *BounderMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *BounderMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("BounderMock.CleanUpSupplementsFunc: method is nil but Bounder.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedBounder.CleanUpSupplementsCalls())
func (mock *BounderMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *BounderMock) Start(ctx context.Context, ownerRef *metav1.OwnerReference, sup supplements.Generator, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("BounderMock.StartFunc: method is nil but Bounder.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		OwnerRef *metav1.OwnerReference
		Sup      supplements.Generator
		Opts     []service.Option
	}{
		Ctx:      ctx,
		OwnerRef: ownerRef,
		Sup:      sup,
		Opts:     opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, ownerRef, sup, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedBounder.StartCalls())
func (mock *BounderMock) StartCalls() []struct {
	Ctx      context.Context
	OwnerRef *metav1.OwnerReference
	Sup      supplements.Generator
	Opts     []service.Option
} {
	var calls []struct {
		Ctx      context.Context
		OwnerRef *metav1.OwnerReference
		Sup      supplements.Generator
		Opts     []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Ensure, that HandlerMock does implement Handler.
// If this is not the case, regenerate this file with moq.
var _ Handler = &HandlerMock{}

// HandlerMock is a mock implementation of Handler.
//
//	func TestSomethingThatUsesHandler(t *testing.T) {
//
//		// make and configure a mocked Handler
//		mockedHandler := &HandlerMock{
//			CleanUpFunc: func(ctx context.Context, vi *v1alpha2.VirtualImage) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			StoreToDVCRFunc: func(ctx context.Context, vi *v1alpha2.VirtualImage) (reconcile.Result, error) {
//				panic("mock out the StoreToDVCR method")
//			},
//			StoreToPVCFunc: func(ctx context.Context, vi *v1alpha2.VirtualImage) (reconcile.Result, error) {
//				panic("mock out the StoreToPVC method")
//			},
//			ValidateFunc: func(ctx context.Context, vi *v1alpha2.VirtualImage) error {
//				panic("mock out the Validate method")
//			},
//		}
//
//		// use mockedHandler in code that requires Handler
//		// and then make assertions.
//
//	}
type HandlerMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, vi *v1alpha2.VirtualImage) (bool, error)

	// StoreToDVCRFunc mocks the StoreToDVCR method.
	StoreToDVCRFunc func(ctx context.Context, vi *v1alpha2.VirtualImage) (reconcile.Result, error)

	// StoreToPVCFunc mocks the StoreToPVC method.
	StoreToPVCFunc func(ctx context.Context, vi *v1alpha2.VirtualImage) (reconcile.Result, error)

	// ValidateFunc mocks the Validate method.
	ValidateFunc func(ctx context.Context, vi *v1alpha2.VirtualImage) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *v1alpha2.VirtualImage
		}
		// StoreToDVCR holds details about calls to the StoreToDVCR method.
		StoreToDVCR []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *v1alpha2.VirtualImage
		}
		// StoreToPVC holds details about calls to the StoreToPVC method.
		StoreToPVC []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *v1alpha2.VirtualImage
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *v1alpha2.VirtualImage
		}
	}
	lockCleanUp     sync.RWMutex
	lockStoreToDVCR sync.RWMutex
	lockStoreToPVC  sync.RWMutex
	lockValidate    sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *HandlerMock) CleanUp(ctx context.Context, vi *v1alpha2.VirtualImage) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("HandlerMock.CleanUpFunc: method is nil but Handler.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, vi)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedHandler.CleanUpCalls())
func (mock *HandlerMock) CleanUpCalls() []struct {
	Ctx context.Context
	Vi  *v1alpha2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// StoreToDVCR calls StoreToDVCRFunc.
func (mock *HandlerMock) StoreToDVCR(ctx context.Context, vi *v1alpha2.VirtualImage) (reconcile.Result, error) {
	if mock.StoreToDVCRFunc == nil {
		panic("HandlerMock.StoreToDVCRFunc: method is nil but Handler.StoreToDVCR was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockStoreToDVCR.Lock()
	mock.calls.StoreToDVCR = append(mock.calls.StoreToDVCR, callInfo)
	mock.lockStoreToDVCR.Unlock()
	return mock.StoreToDVCRFunc(ctx, vi)
}

// StoreToDVCRCalls gets all the calls that were made to StoreToDVCR.
// Check the length with:
//
//	len(mockedHandler.StoreToDVCRCalls())
func (mock *HandlerMock) StoreToDVCRCalls() []struct {
	Ctx context.Context
	Vi  *v1alpha2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}
	mock.lockStoreToDVCR.RLock()
	calls = mock.calls.StoreToDVCR
	mock.lockStoreToDVCR.RUnlock()
	return calls
}

// StoreToPVC calls StoreToPVCFunc.
func (mock *HandlerMock) StoreToPVC(ctx context.Context, vi *v1alpha2.VirtualImage) (reconcile.Result, error) {
	if mock.StoreToPVCFunc == nil {
		panic("HandlerMock.StoreToPVCFunc: method is nil but Handler.StoreToPVC was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockStoreToPVC.Lock()
	mock.calls.StoreToPVC = append(mock.calls.StoreToPVC, callInfo)
	mock.lockStoreToPVC.Unlock()
	return mock.StoreToPVCFunc(ctx, vi)
}

// StoreToPVCCalls gets all the calls that were made to StoreToPVC.
// Check the length with:
//
//	len(mockedHandler.StoreToPVCCalls())
func (mock *HandlerMock) StoreToPVCCalls() []struct {
	Ctx context.Context
	Vi  *v1alpha2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}
	mock.lockStoreToPVC.RLock()
	calls = mock.calls.StoreToPVC
	mock.lockStoreToPVC.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *HandlerMock) Validate(ctx context.Context, vi *v1alpha2.VirtualImage) error {
	if mock.ValidateFunc == nil {
		panic("HandlerMock.ValidateFunc: method is nil but Handler.Validate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	return mock.ValidateFunc(ctx, vi)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//
//	len(mockedHandler.ValidateCalls())
func (mock *HandlerMock) ValidateCalls() []struct {
	Ctx context.Context
	Vi  *v1alpha2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *v1alpha2.VirtualImage
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}

// Ensure, that DiskMock does implement Disk.
// If this is not the case, regenerate this file with moq.
var _ Disk = &DiskMock{}

// DiskMock is a mock implementation of Disk.
//
//	func TestSomethingThatUsesDisk(t *testing.T) {
//
//		// make and configure a mocked Disk
//		mockedDisk := &DiskMock{
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetPersistentVolumeClaimFunc: func(ctx context.Context, sup supplements.Generator) (*corev1.PersistentVolumeClaim, error) {
//				panic("mock out the GetPersistentVolumeClaim method")
//			},
//		}
//
//		// use mockedDisk in code that requires Disk
//		// and then make assertions.
//
//	}
type DiskMock struct {
	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// GetPersistentVolumeClaimFunc mocks the GetPersistentVolumeClaim method.
	GetPersistentVolumeClaimFunc func(ctx context.Context, sup supplements.Generator) (*corev1.PersistentVolumeClaim, error)

	// calls tracks calls to the methods.
	calls struct {
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetPersistentVolumeClaim holds details about calls to the GetPersistentVolumeClaim method.
		GetPersistentVolumeClaim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
	}
	lockCleanUpSupplements       sync.RWMutex
	lockGetPersistentVolumeClaim sync.RWMutex
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *DiskMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("DiskMock.CleanUpSupplementsFunc: method is nil but Disk.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedDisk.CleanUpSupplementsCalls())
func (mock *DiskMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetPersistentVolumeClaim calls GetPersistentVolumeClaimFunc.
func (mock *DiskMock) GetPersistentVolumeClaim(ctx context.Context, sup supplements.Generator) (*corev1.PersistentVolumeClaim, error) {
	if mock.GetPersistentVolumeClaimFunc == nil {
		panic("DiskMock.GetPersistentVolumeClaimFunc: method is nil but Disk.GetPersistentVolumeClaim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetPersistentVolumeClaim.Lock()
	mock.calls.GetPersistentVolumeClaim = append(mock.calls.GetPersistentVolumeClaim, callInfo)
	mock.lockGetPersistentVolumeClaim.Unlock()
	return mock.GetPersistentVolumeClaimFunc(ctx, sup)
}

// GetPersistentVolumeClaimCalls gets all the calls that were made to GetPersistentVolumeClaim.
// Check the length with:
//
//	len(mockedDisk.GetPersistentVolumeClaimCalls())
func (mock *DiskMock) GetPersistentVolumeClaimCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockGetPersistentVolumeClaim.RLock()
	calls = mock.calls.GetPersistentVolumeClaim
	mock.lockGetPersistentVolumeClaim.RUnlock()
	return calls
}
