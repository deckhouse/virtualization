/*
Copyright 2025 Flant JSC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package source

import (
	"context"
	"github.com/deckhouse/virtualization-controller/pkg/common/datasource"
	"github.com/deckhouse/virtualization-controller/pkg/controller/importer"
	"github.com/deckhouse/virtualization-controller/pkg/controller/service"
	"github.com/deckhouse/virtualization-controller/pkg/controller/supplements"
	"github.com/deckhouse/virtualization-controller/pkg/controller/uploader"
	virtv2 "github.com/deckhouse/virtualization/api/core/v1alpha2"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	"sync"
)

// Ensure, that ImporterMock does implement Importer.
// If this is not the case, regenerate this file with moq.
var _ Importer = &ImporterMock{}

// ImporterMock is a mock implementation of Importer.
//
//	func TestSomethingThatUsesImporter(t *testing.T) {
//
//		// make and configure a mocked Importer
//		mockedImporter := &ImporterMock{
//			CleanUpFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetPodFunc: func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
//				panic("mock out the GetPod method")
//			},
//			GetPodSettingsWithPVCFunc: func(ownerReference *metav1.OwnerReference, generator *supplements.Generator, s1 string, s2 string) *importer.PodSettings {
//				panic("mock out the GetPodSettingsWithPVC method")
//			},
//			ProtectFunc: func(ctx context.Context, pod *corev1.Pod) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, settings *importer.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//			StartWithPodSettingFunc: func(contextMoqParam context.Context, settings *importer.Settings, generator *supplements.Generator, cABundle *datasource.CABundle, podSettings *importer.PodSettings) error {
//				panic("mock out the StartWithPodSetting method")
//			},
//			UnprotectFunc: func(ctx context.Context, pod *corev1.Pod) error {
//				panic("mock out the Unprotect method")
//			},
//		}
//
//		// use mockedImporter in code that requires Importer
//		// and then make assertions.
//
//	}
type ImporterMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// GetPodFunc mocks the GetPod method.
	GetPodFunc func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error)

	// GetPodSettingsWithPVCFunc mocks the GetPodSettingsWithPVC method.
	GetPodSettingsWithPVCFunc func(ownerReference *metav1.OwnerReference, generator *supplements.Generator, s1 string, s2 string) *importer.PodSettings

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, pod *corev1.Pod) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, settings *importer.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error

	// StartWithPodSettingFunc mocks the StartWithPodSetting method.
	StartWithPodSettingFunc func(contextMoqParam context.Context, settings *importer.Settings, generator *supplements.Generator, cABundle *datasource.CABundle, podSettings *importer.PodSettings) error

	// UnprotectFunc mocks the Unprotect method.
	UnprotectFunc func(ctx context.Context, pod *corev1.Pod) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetPod holds details about calls to the GetPod method.
		GetPod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetPodSettingsWithPVC holds details about calls to the GetPodSettingsWithPVC method.
		GetPodSettingsWithPVC []struct {
			// OwnerReference is the ownerReference argument value.
			OwnerReference *metav1.OwnerReference
			// Generator is the generator argument value.
			Generator *supplements.Generator
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *importer.Settings
			// Obj is the obj argument value.
			Obj service.ObjectKind
			// Sup is the sup argument value.
			Sup *supplements.Generator
			// CaBundle is the caBundle argument value.
			CaBundle *datasource.CABundle
			// Opts is the opts argument value.
			Opts []service.Option
		}
		// StartWithPodSetting holds details about calls to the StartWithPodSetting method.
		StartWithPodSetting []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Settings is the settings argument value.
			Settings *importer.Settings
			// Generator is the generator argument value.
			Generator *supplements.Generator
			// CABundle is the cABundle argument value.
			CABundle *datasource.CABundle
			// PodSettings is the podSettings argument value.
			PodSettings *importer.PodSettings
		}
		// Unprotect holds details about calls to the Unprotect method.
		Unprotect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
	}
	lockCleanUp               sync.RWMutex
	lockCleanUpSupplements    sync.RWMutex
	lockGetPod                sync.RWMutex
	lockGetPodSettingsWithPVC sync.RWMutex
	lockProtect               sync.RWMutex
	lockStart                 sync.RWMutex
	lockStartWithPodSetting   sync.RWMutex
	lockUnprotect             sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *ImporterMock) CleanUp(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("ImporterMock.CleanUpFunc: method is nil but Importer.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedImporter.CleanUpCalls())
func (mock *ImporterMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *ImporterMock) CleanUpSupplements(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("ImporterMock.CleanUpSupplementsFunc: method is nil but Importer.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedImporter.CleanUpSupplementsCalls())
func (mock *ImporterMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetPod calls GetPodFunc.
func (mock *ImporterMock) GetPod(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
	if mock.GetPodFunc == nil {
		panic("ImporterMock.GetPodFunc: method is nil but Importer.GetPod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetPod.Lock()
	mock.calls.GetPod = append(mock.calls.GetPod, callInfo)
	mock.lockGetPod.Unlock()
	return mock.GetPodFunc(ctx, sup)
}

// GetPodCalls gets all the calls that were made to GetPod.
// Check the length with:
//
//	len(mockedImporter.GetPodCalls())
func (mock *ImporterMock) GetPodCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetPod.RLock()
	calls = mock.calls.GetPod
	mock.lockGetPod.RUnlock()
	return calls
}

// GetPodSettingsWithPVC calls GetPodSettingsWithPVCFunc.
func (mock *ImporterMock) GetPodSettingsWithPVC(ownerReference *metav1.OwnerReference, generator *supplements.Generator, s1 string, s2 string) *importer.PodSettings {
	if mock.GetPodSettingsWithPVCFunc == nil {
		panic("ImporterMock.GetPodSettingsWithPVCFunc: method is nil but Importer.GetPodSettingsWithPVC was just called")
	}
	callInfo := struct {
		OwnerReference *metav1.OwnerReference
		Generator      *supplements.Generator
		S1             string
		S2             string
	}{
		OwnerReference: ownerReference,
		Generator:      generator,
		S1:             s1,
		S2:             s2,
	}
	mock.lockGetPodSettingsWithPVC.Lock()
	mock.calls.GetPodSettingsWithPVC = append(mock.calls.GetPodSettingsWithPVC, callInfo)
	mock.lockGetPodSettingsWithPVC.Unlock()
	return mock.GetPodSettingsWithPVCFunc(ownerReference, generator, s1, s2)
}

// GetPodSettingsWithPVCCalls gets all the calls that were made to GetPodSettingsWithPVC.
// Check the length with:
//
//	len(mockedImporter.GetPodSettingsWithPVCCalls())
func (mock *ImporterMock) GetPodSettingsWithPVCCalls() []struct {
	OwnerReference *metav1.OwnerReference
	Generator      *supplements.Generator
	S1             string
	S2             string
} {
	var calls []struct {
		OwnerReference *metav1.OwnerReference
		Generator      *supplements.Generator
		S1             string
		S2             string
	}
	mock.lockGetPodSettingsWithPVC.RLock()
	calls = mock.calls.GetPodSettingsWithPVC
	mock.lockGetPodSettingsWithPVC.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *ImporterMock) Protect(ctx context.Context, pod *corev1.Pod) error {
	if mock.ProtectFunc == nil {
		panic("ImporterMock.ProtectFunc: method is nil but Importer.Protect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
	}{
		Ctx: ctx,
		Pod: pod,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, pod)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedImporter.ProtectCalls())
func (mock *ImporterMock) ProtectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *ImporterMock) Start(ctx context.Context, settings *importer.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("ImporterMock.StartFunc: method is nil but Importer.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Settings *importer.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}{
		Ctx:      ctx,
		Settings: settings,
		Obj:      obj,
		Sup:      sup,
		CaBundle: caBundle,
		Opts:     opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, settings, obj, sup, caBundle, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedImporter.StartCalls())
func (mock *ImporterMock) StartCalls() []struct {
	Ctx      context.Context
	Settings *importer.Settings
	Obj      service.ObjectKind
	Sup      *supplements.Generator
	CaBundle *datasource.CABundle
	Opts     []service.Option
} {
	var calls []struct {
		Ctx      context.Context
		Settings *importer.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// StartWithPodSetting calls StartWithPodSettingFunc.
func (mock *ImporterMock) StartWithPodSetting(contextMoqParam context.Context, settings *importer.Settings, generator *supplements.Generator, cABundle *datasource.CABundle, podSettings *importer.PodSettings) error {
	if mock.StartWithPodSettingFunc == nil {
		panic("ImporterMock.StartWithPodSettingFunc: method is nil but Importer.StartWithPodSetting was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Settings        *importer.Settings
		Generator       *supplements.Generator
		CABundle        *datasource.CABundle
		PodSettings     *importer.PodSettings
	}{
		ContextMoqParam: contextMoqParam,
		Settings:        settings,
		Generator:       generator,
		CABundle:        cABundle,
		PodSettings:     podSettings,
	}
	mock.lockStartWithPodSetting.Lock()
	mock.calls.StartWithPodSetting = append(mock.calls.StartWithPodSetting, callInfo)
	mock.lockStartWithPodSetting.Unlock()
	return mock.StartWithPodSettingFunc(contextMoqParam, settings, generator, cABundle, podSettings)
}

// StartWithPodSettingCalls gets all the calls that were made to StartWithPodSetting.
// Check the length with:
//
//	len(mockedImporter.StartWithPodSettingCalls())
func (mock *ImporterMock) StartWithPodSettingCalls() []struct {
	ContextMoqParam context.Context
	Settings        *importer.Settings
	Generator       *supplements.Generator
	CABundle        *datasource.CABundle
	PodSettings     *importer.PodSettings
} {
	var calls []struct {
		ContextMoqParam context.Context
		Settings        *importer.Settings
		Generator       *supplements.Generator
		CABundle        *datasource.CABundle
		PodSettings     *importer.PodSettings
	}
	mock.lockStartWithPodSetting.RLock()
	calls = mock.calls.StartWithPodSetting
	mock.lockStartWithPodSetting.RUnlock()
	return calls
}

// Unprotect calls UnprotectFunc.
func (mock *ImporterMock) Unprotect(ctx context.Context, pod *corev1.Pod) error {
	if mock.UnprotectFunc == nil {
		panic("ImporterMock.UnprotectFunc: method is nil but Importer.Unprotect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
	}{
		Ctx: ctx,
		Pod: pod,
	}
	mock.lockUnprotect.Lock()
	mock.calls.Unprotect = append(mock.calls.Unprotect, callInfo)
	mock.lockUnprotect.Unlock()
	return mock.UnprotectFunc(ctx, pod)
}

// UnprotectCalls gets all the calls that were made to Unprotect.
// Check the length with:
//
//	len(mockedImporter.UnprotectCalls())
func (mock *ImporterMock) UnprotectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
	}
	mock.lockUnprotect.RLock()
	calls = mock.calls.Unprotect
	mock.lockUnprotect.RUnlock()
	return calls
}

// Ensure, that UploaderMock does implement Uploader.
// If this is not the case, regenerate this file with moq.
var _ Uploader = &UploaderMock{}

// UploaderMock is a mock implementation of Uploader.
//
//	func TestSomethingThatUsesUploader(t *testing.T) {
//
//		// make and configure a mocked Uploader
//		mockedUploader := &UploaderMock{
//			CleanUpFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetExternalURLFunc: func(ctx context.Context, ing *netv1.Ingress) string {
//				panic("mock out the GetExternalURL method")
//			},
//			GetInClusterURLFunc: func(ctx context.Context, svc *corev1.Service) string {
//				panic("mock out the GetInClusterURL method")
//			},
//			GetIngressFunc: func(ctx context.Context, sup *supplements.Generator) (*netv1.Ingress, error) {
//				panic("mock out the GetIngress method")
//			},
//			GetPodFunc: func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
//				panic("mock out the GetPod method")
//			},
//			GetServiceFunc: func(ctx context.Context, sup *supplements.Generator) (*corev1.Service, error) {
//				panic("mock out the GetService method")
//			},
//			ProtectFunc: func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, settings *uploader.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//			UnprotectFunc: func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
//				panic("mock out the Unprotect method")
//			},
//		}
//
//		// use mockedUploader in code that requires Uploader
//		// and then make assertions.
//
//	}
type UploaderMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// GetExternalURLFunc mocks the GetExternalURL method.
	GetExternalURLFunc func(ctx context.Context, ing *netv1.Ingress) string

	// GetInClusterURLFunc mocks the GetInClusterURL method.
	GetInClusterURLFunc func(ctx context.Context, svc *corev1.Service) string

	// GetIngressFunc mocks the GetIngress method.
	GetIngressFunc func(ctx context.Context, sup *supplements.Generator) (*netv1.Ingress, error)

	// GetPodFunc mocks the GetPod method.
	GetPodFunc func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error)

	// GetServiceFunc mocks the GetService method.
	GetServiceFunc func(ctx context.Context, sup *supplements.Generator) (*corev1.Service, error)

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, settings *uploader.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error

	// UnprotectFunc mocks the Unprotect method.
	UnprotectFunc func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetExternalURL holds details about calls to the GetExternalURL method.
		GetExternalURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
		// GetInClusterURL holds details about calls to the GetInClusterURL method.
		GetInClusterURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Svc is the svc argument value.
			Svc *corev1.Service
		}
		// GetIngress holds details about calls to the GetIngress method.
		GetIngress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetPod holds details about calls to the GetPod method.
		GetPod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetService holds details about calls to the GetService method.
		GetService []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *uploader.Settings
			// Obj is the obj argument value.
			Obj service.ObjectKind
			// Sup is the sup argument value.
			Sup *supplements.Generator
			// CaBundle is the caBundle argument value.
			CaBundle *datasource.CABundle
			// Opts is the opts argument value.
			Opts []service.Option
		}
		// Unprotect holds details about calls to the Unprotect method.
		Unprotect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
	}
	lockCleanUp            sync.RWMutex
	lockCleanUpSupplements sync.RWMutex
	lockGetExternalURL     sync.RWMutex
	lockGetInClusterURL    sync.RWMutex
	lockGetIngress         sync.RWMutex
	lockGetPod             sync.RWMutex
	lockGetService         sync.RWMutex
	lockProtect            sync.RWMutex
	lockStart              sync.RWMutex
	lockUnprotect          sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *UploaderMock) CleanUp(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("UploaderMock.CleanUpFunc: method is nil but Uploader.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedUploader.CleanUpCalls())
func (mock *UploaderMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *UploaderMock) CleanUpSupplements(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("UploaderMock.CleanUpSupplementsFunc: method is nil but Uploader.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedUploader.CleanUpSupplementsCalls())
func (mock *UploaderMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetExternalURL calls GetExternalURLFunc.
func (mock *UploaderMock) GetExternalURL(ctx context.Context, ing *netv1.Ingress) string {
	if mock.GetExternalURLFunc == nil {
		panic("UploaderMock.GetExternalURLFunc: method is nil but Uploader.GetExternalURL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Ing: ing,
	}
	mock.lockGetExternalURL.Lock()
	mock.calls.GetExternalURL = append(mock.calls.GetExternalURL, callInfo)
	mock.lockGetExternalURL.Unlock()
	return mock.GetExternalURLFunc(ctx, ing)
}

// GetExternalURLCalls gets all the calls that were made to GetExternalURL.
// Check the length with:
//
//	len(mockedUploader.GetExternalURLCalls())
func (mock *UploaderMock) GetExternalURLCalls() []struct {
	Ctx context.Context
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Ing *netv1.Ingress
	}
	mock.lockGetExternalURL.RLock()
	calls = mock.calls.GetExternalURL
	mock.lockGetExternalURL.RUnlock()
	return calls
}

// GetInClusterURL calls GetInClusterURLFunc.
func (mock *UploaderMock) GetInClusterURL(ctx context.Context, svc *corev1.Service) string {
	if mock.GetInClusterURLFunc == nil {
		panic("UploaderMock.GetInClusterURLFunc: method is nil but Uploader.GetInClusterURL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Svc *corev1.Service
	}{
		Ctx: ctx,
		Svc: svc,
	}
	mock.lockGetInClusterURL.Lock()
	mock.calls.GetInClusterURL = append(mock.calls.GetInClusterURL, callInfo)
	mock.lockGetInClusterURL.Unlock()
	return mock.GetInClusterURLFunc(ctx, svc)
}

// GetInClusterURLCalls gets all the calls that were made to GetInClusterURL.
// Check the length with:
//
//	len(mockedUploader.GetInClusterURLCalls())
func (mock *UploaderMock) GetInClusterURLCalls() []struct {
	Ctx context.Context
	Svc *corev1.Service
} {
	var calls []struct {
		Ctx context.Context
		Svc *corev1.Service
	}
	mock.lockGetInClusterURL.RLock()
	calls = mock.calls.GetInClusterURL
	mock.lockGetInClusterURL.RUnlock()
	return calls
}

// GetIngress calls GetIngressFunc.
func (mock *UploaderMock) GetIngress(ctx context.Context, sup *supplements.Generator) (*netv1.Ingress, error) {
	if mock.GetIngressFunc == nil {
		panic("UploaderMock.GetIngressFunc: method is nil but Uploader.GetIngress was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetIngress.Lock()
	mock.calls.GetIngress = append(mock.calls.GetIngress, callInfo)
	mock.lockGetIngress.Unlock()
	return mock.GetIngressFunc(ctx, sup)
}

// GetIngressCalls gets all the calls that were made to GetIngress.
// Check the length with:
//
//	len(mockedUploader.GetIngressCalls())
func (mock *UploaderMock) GetIngressCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetIngress.RLock()
	calls = mock.calls.GetIngress
	mock.lockGetIngress.RUnlock()
	return calls
}

// GetPod calls GetPodFunc.
func (mock *UploaderMock) GetPod(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
	if mock.GetPodFunc == nil {
		panic("UploaderMock.GetPodFunc: method is nil but Uploader.GetPod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetPod.Lock()
	mock.calls.GetPod = append(mock.calls.GetPod, callInfo)
	mock.lockGetPod.Unlock()
	return mock.GetPodFunc(ctx, sup)
}

// GetPodCalls gets all the calls that were made to GetPod.
// Check the length with:
//
//	len(mockedUploader.GetPodCalls())
func (mock *UploaderMock) GetPodCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetPod.RLock()
	calls = mock.calls.GetPod
	mock.lockGetPod.RUnlock()
	return calls
}

// GetService calls GetServiceFunc.
func (mock *UploaderMock) GetService(ctx context.Context, sup *supplements.Generator) (*corev1.Service, error) {
	if mock.GetServiceFunc == nil {
		panic("UploaderMock.GetServiceFunc: method is nil but Uploader.GetService was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetService.Lock()
	mock.calls.GetService = append(mock.calls.GetService, callInfo)
	mock.lockGetService.Unlock()
	return mock.GetServiceFunc(ctx, sup)
}

// GetServiceCalls gets all the calls that were made to GetService.
// Check the length with:
//
//	len(mockedUploader.GetServiceCalls())
func (mock *UploaderMock) GetServiceCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetService.RLock()
	calls = mock.calls.GetService
	mock.lockGetService.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *UploaderMock) Protect(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
	if mock.ProtectFunc == nil {
		panic("UploaderMock.ProtectFunc: method is nil but Uploader.Protect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, pod, svc, ing)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedUploader.ProtectCalls())
func (mock *UploaderMock) ProtectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *UploaderMock) Start(ctx context.Context, settings *uploader.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("UploaderMock.StartFunc: method is nil but Uploader.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Settings *uploader.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}{
		Ctx:      ctx,
		Settings: settings,
		Obj:      obj,
		Sup:      sup,
		CaBundle: caBundle,
		Opts:     opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, settings, obj, sup, caBundle, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedUploader.StartCalls())
func (mock *UploaderMock) StartCalls() []struct {
	Ctx      context.Context
	Settings *uploader.Settings
	Obj      service.ObjectKind
	Sup      *supplements.Generator
	CaBundle *datasource.CABundle
	Opts     []service.Option
} {
	var calls []struct {
		Ctx      context.Context
		Settings *uploader.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
		Opts     []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Unprotect calls UnprotectFunc.
func (mock *UploaderMock) Unprotect(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
	if mock.UnprotectFunc == nil {
		panic("UploaderMock.UnprotectFunc: method is nil but Uploader.Unprotect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockUnprotect.Lock()
	mock.calls.Unprotect = append(mock.calls.Unprotect, callInfo)
	mock.lockUnprotect.Unlock()
	return mock.UnprotectFunc(ctx, pod, svc, ing)
}

// UnprotectCalls gets all the calls that were made to Unprotect.
// Check the length with:
//
//	len(mockedUploader.UnprotectCalls())
func (mock *UploaderMock) UnprotectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockUnprotect.RLock()
	calls = mock.calls.Unprotect
	mock.lockUnprotect.RUnlock()
	return calls
}

// Ensure, that StatMock does implement Stat.
// If this is not the case, regenerate this file with moq.
var _ Stat = &StatMock{}

// StatMock is a mock implementation of Stat.
//
//	func TestSomethingThatUsesStat(t *testing.T) {
//
//		// make and configure a mocked Stat
//		mockedStat := &StatMock{
//			CheckPodFunc: func(pod *corev1.Pod) error {
//				panic("mock out the CheckPod method")
//			},
//			GetCDROMFunc: func(pod *corev1.Pod) bool {
//				panic("mock out the GetCDROM method")
//			},
//			GetDVCRImageNameFunc: func(pod *corev1.Pod) string {
//				panic("mock out the GetDVCRImageName method")
//			},
//			GetDownloadSpeedFunc: func(ownerUID types.UID, pod *corev1.Pod) *virtv2.StatusSpeed {
//				panic("mock out the GetDownloadSpeed method")
//			},
//			GetFormatFunc: func(pod *corev1.Pod) string {
//				panic("mock out the GetFormat method")
//			},
//			GetProgressFunc: func(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string {
//				panic("mock out the GetProgress method")
//			},
//			GetSizeFunc: func(pod *corev1.Pod) virtv2.ImageStatusSize {
//				panic("mock out the GetSize method")
//			},
//			IsUploadStartedFunc: func(ownerUID types.UID, pod *corev1.Pod) bool {
//				panic("mock out the IsUploadStarted method")
//			},
//			IsUploaderReadyFunc: func(pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) bool {
//				panic("mock out the IsUploaderReady method")
//			},
//		}
//
//		// use mockedStat in code that requires Stat
//		// and then make assertions.
//
//	}
type StatMock struct {
	// CheckPodFunc mocks the CheckPod method.
	CheckPodFunc func(pod *corev1.Pod) error

	// GetCDROMFunc mocks the GetCDROM method.
	GetCDROMFunc func(pod *corev1.Pod) bool

	// GetDVCRImageNameFunc mocks the GetDVCRImageName method.
	GetDVCRImageNameFunc func(pod *corev1.Pod) string

	// GetDownloadSpeedFunc mocks the GetDownloadSpeed method.
	GetDownloadSpeedFunc func(ownerUID types.UID, pod *corev1.Pod) *virtv2.StatusSpeed

	// GetFormatFunc mocks the GetFormat method.
	GetFormatFunc func(pod *corev1.Pod) string

	// GetProgressFunc mocks the GetProgress method.
	GetProgressFunc func(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string

	// GetSizeFunc mocks the GetSize method.
	GetSizeFunc func(pod *corev1.Pod) virtv2.ImageStatusSize

	// IsUploadStartedFunc mocks the IsUploadStarted method.
	IsUploadStartedFunc func(ownerUID types.UID, pod *corev1.Pod) bool

	// IsUploaderReadyFunc mocks the IsUploaderReady method.
	IsUploaderReadyFunc func(pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) bool

	// calls tracks calls to the methods.
	calls struct {
		// CheckPod holds details about calls to the CheckPod method.
		CheckPod []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetCDROM holds details about calls to the GetCDROM method.
		GetCDROM []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetDVCRImageName holds details about calls to the GetDVCRImageName method.
		GetDVCRImageName []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetDownloadSpeed holds details about calls to the GetDownloadSpeed method.
		GetDownloadSpeed []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetFormat holds details about calls to the GetFormat method.
		GetFormat []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetProgress holds details about calls to the GetProgress method.
		GetProgress []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// PrevProgress is the prevProgress argument value.
			PrevProgress string
			// Opts is the opts argument value.
			Opts []service.GetProgressOption
		}
		// GetSize holds details about calls to the GetSize method.
		GetSize []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// IsUploadStarted holds details about calls to the IsUploadStarted method.
		IsUploadStarted []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// IsUploaderReady holds details about calls to the IsUploaderReady method.
		IsUploaderReady []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
	}
	lockCheckPod         sync.RWMutex
	lockGetCDROM         sync.RWMutex
	lockGetDVCRImageName sync.RWMutex
	lockGetDownloadSpeed sync.RWMutex
	lockGetFormat        sync.RWMutex
	lockGetProgress      sync.RWMutex
	lockGetSize          sync.RWMutex
	lockIsUploadStarted  sync.RWMutex
	lockIsUploaderReady  sync.RWMutex
}

// CheckPod calls CheckPodFunc.
func (mock *StatMock) CheckPod(pod *corev1.Pod) error {
	if mock.CheckPodFunc == nil {
		panic("StatMock.CheckPodFunc: method is nil but Stat.CheckPod was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockCheckPod.Lock()
	mock.calls.CheckPod = append(mock.calls.CheckPod, callInfo)
	mock.lockCheckPod.Unlock()
	return mock.CheckPodFunc(pod)
}

// CheckPodCalls gets all the calls that were made to CheckPod.
// Check the length with:
//
//	len(mockedStat.CheckPodCalls())
func (mock *StatMock) CheckPodCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockCheckPod.RLock()
	calls = mock.calls.CheckPod
	mock.lockCheckPod.RUnlock()
	return calls
}

// GetCDROM calls GetCDROMFunc.
func (mock *StatMock) GetCDROM(pod *corev1.Pod) bool {
	if mock.GetCDROMFunc == nil {
		panic("StatMock.GetCDROMFunc: method is nil but Stat.GetCDROM was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetCDROM.Lock()
	mock.calls.GetCDROM = append(mock.calls.GetCDROM, callInfo)
	mock.lockGetCDROM.Unlock()
	return mock.GetCDROMFunc(pod)
}

// GetCDROMCalls gets all the calls that were made to GetCDROM.
// Check the length with:
//
//	len(mockedStat.GetCDROMCalls())
func (mock *StatMock) GetCDROMCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetCDROM.RLock()
	calls = mock.calls.GetCDROM
	mock.lockGetCDROM.RUnlock()
	return calls
}

// GetDVCRImageName calls GetDVCRImageNameFunc.
func (mock *StatMock) GetDVCRImageName(pod *corev1.Pod) string {
	if mock.GetDVCRImageNameFunc == nil {
		panic("StatMock.GetDVCRImageNameFunc: method is nil but Stat.GetDVCRImageName was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetDVCRImageName.Lock()
	mock.calls.GetDVCRImageName = append(mock.calls.GetDVCRImageName, callInfo)
	mock.lockGetDVCRImageName.Unlock()
	return mock.GetDVCRImageNameFunc(pod)
}

// GetDVCRImageNameCalls gets all the calls that were made to GetDVCRImageName.
// Check the length with:
//
//	len(mockedStat.GetDVCRImageNameCalls())
func (mock *StatMock) GetDVCRImageNameCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetDVCRImageName.RLock()
	calls = mock.calls.GetDVCRImageName
	mock.lockGetDVCRImageName.RUnlock()
	return calls
}

// GetDownloadSpeed calls GetDownloadSpeedFunc.
func (mock *StatMock) GetDownloadSpeed(ownerUID types.UID, pod *corev1.Pod) *virtv2.StatusSpeed {
	if mock.GetDownloadSpeedFunc == nil {
		panic("StatMock.GetDownloadSpeedFunc: method is nil but Stat.GetDownloadSpeed was just called")
	}
	callInfo := struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}{
		OwnerUID: ownerUID,
		Pod:      pod,
	}
	mock.lockGetDownloadSpeed.Lock()
	mock.calls.GetDownloadSpeed = append(mock.calls.GetDownloadSpeed, callInfo)
	mock.lockGetDownloadSpeed.Unlock()
	return mock.GetDownloadSpeedFunc(ownerUID, pod)
}

// GetDownloadSpeedCalls gets all the calls that were made to GetDownloadSpeed.
// Check the length with:
//
//	len(mockedStat.GetDownloadSpeedCalls())
func (mock *StatMock) GetDownloadSpeedCalls() []struct {
	OwnerUID types.UID
	Pod      *corev1.Pod
} {
	var calls []struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}
	mock.lockGetDownloadSpeed.RLock()
	calls = mock.calls.GetDownloadSpeed
	mock.lockGetDownloadSpeed.RUnlock()
	return calls
}

// GetFormat calls GetFormatFunc.
func (mock *StatMock) GetFormat(pod *corev1.Pod) string {
	if mock.GetFormatFunc == nil {
		panic("StatMock.GetFormatFunc: method is nil but Stat.GetFormat was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetFormat.Lock()
	mock.calls.GetFormat = append(mock.calls.GetFormat, callInfo)
	mock.lockGetFormat.Unlock()
	return mock.GetFormatFunc(pod)
}

// GetFormatCalls gets all the calls that were made to GetFormat.
// Check the length with:
//
//	len(mockedStat.GetFormatCalls())
func (mock *StatMock) GetFormatCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetFormat.RLock()
	calls = mock.calls.GetFormat
	mock.lockGetFormat.RUnlock()
	return calls
}

// GetProgress calls GetProgressFunc.
func (mock *StatMock) GetProgress(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string {
	if mock.GetProgressFunc == nil {
		panic("StatMock.GetProgressFunc: method is nil but Stat.GetProgress was just called")
	}
	callInfo := struct {
		OwnerUID     types.UID
		Pod          *corev1.Pod
		PrevProgress string
		Opts         []service.GetProgressOption
	}{
		OwnerUID:     ownerUID,
		Pod:          pod,
		PrevProgress: prevProgress,
		Opts:         opts,
	}
	mock.lockGetProgress.Lock()
	mock.calls.GetProgress = append(mock.calls.GetProgress, callInfo)
	mock.lockGetProgress.Unlock()
	return mock.GetProgressFunc(ownerUID, pod, prevProgress, opts...)
}

// GetProgressCalls gets all the calls that were made to GetProgress.
// Check the length with:
//
//	len(mockedStat.GetProgressCalls())
func (mock *StatMock) GetProgressCalls() []struct {
	OwnerUID     types.UID
	Pod          *corev1.Pod
	PrevProgress string
	Opts         []service.GetProgressOption
} {
	var calls []struct {
		OwnerUID     types.UID
		Pod          *corev1.Pod
		PrevProgress string
		Opts         []service.GetProgressOption
	}
	mock.lockGetProgress.RLock()
	calls = mock.calls.GetProgress
	mock.lockGetProgress.RUnlock()
	return calls
}

// GetSize calls GetSizeFunc.
func (mock *StatMock) GetSize(pod *corev1.Pod) virtv2.ImageStatusSize {
	if mock.GetSizeFunc == nil {
		panic("StatMock.GetSizeFunc: method is nil but Stat.GetSize was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetSize.Lock()
	mock.calls.GetSize = append(mock.calls.GetSize, callInfo)
	mock.lockGetSize.Unlock()
	return mock.GetSizeFunc(pod)
}

// GetSizeCalls gets all the calls that were made to GetSize.
// Check the length with:
//
//	len(mockedStat.GetSizeCalls())
func (mock *StatMock) GetSizeCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetSize.RLock()
	calls = mock.calls.GetSize
	mock.lockGetSize.RUnlock()
	return calls
}

// IsUploadStarted calls IsUploadStartedFunc.
func (mock *StatMock) IsUploadStarted(ownerUID types.UID, pod *corev1.Pod) bool {
	if mock.IsUploadStartedFunc == nil {
		panic("StatMock.IsUploadStartedFunc: method is nil but Stat.IsUploadStarted was just called")
	}
	callInfo := struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}{
		OwnerUID: ownerUID,
		Pod:      pod,
	}
	mock.lockIsUploadStarted.Lock()
	mock.calls.IsUploadStarted = append(mock.calls.IsUploadStarted, callInfo)
	mock.lockIsUploadStarted.Unlock()
	return mock.IsUploadStartedFunc(ownerUID, pod)
}

// IsUploadStartedCalls gets all the calls that were made to IsUploadStarted.
// Check the length with:
//
//	len(mockedStat.IsUploadStartedCalls())
func (mock *StatMock) IsUploadStartedCalls() []struct {
	OwnerUID types.UID
	Pod      *corev1.Pod
} {
	var calls []struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}
	mock.lockIsUploadStarted.RLock()
	calls = mock.calls.IsUploadStarted
	mock.lockIsUploadStarted.RUnlock()
	return calls
}

// IsUploaderReady calls IsUploaderReadyFunc.
func (mock *StatMock) IsUploaderReady(pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) bool {
	if mock.IsUploaderReadyFunc == nil {
		panic("StatMock.IsUploaderReadyFunc: method is nil but Stat.IsUploaderReady was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockIsUploaderReady.Lock()
	mock.calls.IsUploaderReady = append(mock.calls.IsUploaderReady, callInfo)
	mock.lockIsUploaderReady.Unlock()
	return mock.IsUploaderReadyFunc(pod, svc, ing)
}

// IsUploaderReadyCalls gets all the calls that were made to IsUploaderReady.
// Check the length with:
//
//	len(mockedStat.IsUploaderReadyCalls())
func (mock *StatMock) IsUploaderReadyCalls() []struct {
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockIsUploaderReady.RLock()
	calls = mock.calls.IsUploaderReady
	mock.lockIsUploaderReady.RUnlock()
	return calls
}

// Ensure, that BounderMock does implement Bounder.
// If this is not the case, regenerate this file with moq.
var _ Bounder = &BounderMock{}

// BounderMock is a mock implementation of Bounder.
//
//	func TestSomethingThatUsesBounder(t *testing.T) {
//
//		// make and configure a mocked Bounder
//		mockedBounder := &BounderMock{
//			CleanUpFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			StartFunc: func(ctx context.Context, ownerRef *metav1.OwnerReference, sup *supplements.Generator, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//		}
//
//		// use mockedBounder in code that requires Bounder
//		// and then make assertions.
//
//	}
type BounderMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, ownerRef *metav1.OwnerReference, sup *supplements.Generator, opts ...service.Option) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OwnerRef is the ownerRef argument value.
			OwnerRef *metav1.OwnerReference
			// Sup is the sup argument value.
			Sup *supplements.Generator
			// Opts is the opts argument value.
			Opts []service.Option
		}
	}
	lockCleanUp            sync.RWMutex
	lockCleanUpSupplements sync.RWMutex
	lockStart              sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *BounderMock) CleanUp(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("BounderMock.CleanUpFunc: method is nil but Bounder.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedBounder.CleanUpCalls())
func (mock *BounderMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *BounderMock) CleanUpSupplements(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("BounderMock.CleanUpSupplementsFunc: method is nil but Bounder.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedBounder.CleanUpSupplementsCalls())
func (mock *BounderMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *BounderMock) Start(ctx context.Context, ownerRef *metav1.OwnerReference, sup *supplements.Generator, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("BounderMock.StartFunc: method is nil but Bounder.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		OwnerRef *metav1.OwnerReference
		Sup      *supplements.Generator
		Opts     []service.Option
	}{
		Ctx:      ctx,
		OwnerRef: ownerRef,
		Sup:      sup,
		Opts:     opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, ownerRef, sup, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedBounder.StartCalls())
func (mock *BounderMock) StartCalls() []struct {
	Ctx      context.Context
	OwnerRef *metav1.OwnerReference
	Sup      *supplements.Generator
	Opts     []service.Option
} {
	var calls []struct {
		Ctx      context.Context
		OwnerRef *metav1.OwnerReference
		Sup      *supplements.Generator
		Opts     []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Ensure, that HandlerMock does implement Handler.
// If this is not the case, regenerate this file with moq.
var _ Handler = &HandlerMock{}

// HandlerMock is a mock implementation of Handler.
//
//	func TestSomethingThatUsesHandler(t *testing.T) {
//
//		// make and configure a mocked Handler
//		mockedHandler := &HandlerMock{
//			CleanUpFunc: func(ctx context.Context, vi *virtv2.VirtualImage) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			StoreToDVCRFunc: func(ctx context.Context, vi *virtv2.VirtualImage) (reconcile.Result, error) {
//				panic("mock out the StoreToDVCR method")
//			},
//			StoreToPVCFunc: func(ctx context.Context, vi *virtv2.VirtualImage) (reconcile.Result, error) {
//				panic("mock out the StoreToPVC method")
//			},
//			ValidateFunc: func(ctx context.Context, vi *virtv2.VirtualImage) error {
//				panic("mock out the Validate method")
//			},
//		}
//
//		// use mockedHandler in code that requires Handler
//		// and then make assertions.
//
//	}
type HandlerMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, vi *virtv2.VirtualImage) (bool, error)

	// StoreToDVCRFunc mocks the StoreToDVCR method.
	StoreToDVCRFunc func(ctx context.Context, vi *virtv2.VirtualImage) (reconcile.Result, error)

	// StoreToPVCFunc mocks the StoreToPVC method.
	StoreToPVCFunc func(ctx context.Context, vi *virtv2.VirtualImage) (reconcile.Result, error)

	// ValidateFunc mocks the Validate method.
	ValidateFunc func(ctx context.Context, vi *virtv2.VirtualImage) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *virtv2.VirtualImage
		}
		// StoreToDVCR holds details about calls to the StoreToDVCR method.
		StoreToDVCR []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *virtv2.VirtualImage
		}
		// StoreToPVC holds details about calls to the StoreToPVC method.
		StoreToPVC []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *virtv2.VirtualImage
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vi is the vi argument value.
			Vi *virtv2.VirtualImage
		}
	}
	lockCleanUp     sync.RWMutex
	lockStoreToDVCR sync.RWMutex
	lockStoreToPVC  sync.RWMutex
	lockValidate    sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *HandlerMock) CleanUp(ctx context.Context, vi *virtv2.VirtualImage) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("HandlerMock.CleanUpFunc: method is nil but Handler.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, vi)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedHandler.CleanUpCalls())
func (mock *HandlerMock) CleanUpCalls() []struct {
	Ctx context.Context
	Vi  *virtv2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// StoreToDVCR calls StoreToDVCRFunc.
func (mock *HandlerMock) StoreToDVCR(ctx context.Context, vi *virtv2.VirtualImage) (reconcile.Result, error) {
	if mock.StoreToDVCRFunc == nil {
		panic("HandlerMock.StoreToDVCRFunc: method is nil but Handler.StoreToDVCR was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockStoreToDVCR.Lock()
	mock.calls.StoreToDVCR = append(mock.calls.StoreToDVCR, callInfo)
	mock.lockStoreToDVCR.Unlock()
	return mock.StoreToDVCRFunc(ctx, vi)
}

// StoreToDVCRCalls gets all the calls that were made to StoreToDVCR.
// Check the length with:
//
//	len(mockedHandler.StoreToDVCRCalls())
func (mock *HandlerMock) StoreToDVCRCalls() []struct {
	Ctx context.Context
	Vi  *virtv2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}
	mock.lockStoreToDVCR.RLock()
	calls = mock.calls.StoreToDVCR
	mock.lockStoreToDVCR.RUnlock()
	return calls
}

// StoreToPVC calls StoreToPVCFunc.
func (mock *HandlerMock) StoreToPVC(ctx context.Context, vi *virtv2.VirtualImage) (reconcile.Result, error) {
	if mock.StoreToPVCFunc == nil {
		panic("HandlerMock.StoreToPVCFunc: method is nil but Handler.StoreToPVC was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockStoreToPVC.Lock()
	mock.calls.StoreToPVC = append(mock.calls.StoreToPVC, callInfo)
	mock.lockStoreToPVC.Unlock()
	return mock.StoreToPVCFunc(ctx, vi)
}

// StoreToPVCCalls gets all the calls that were made to StoreToPVC.
// Check the length with:
//
//	len(mockedHandler.StoreToPVCCalls())
func (mock *HandlerMock) StoreToPVCCalls() []struct {
	Ctx context.Context
	Vi  *virtv2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}
	mock.lockStoreToPVC.RLock()
	calls = mock.calls.StoreToPVC
	mock.lockStoreToPVC.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *HandlerMock) Validate(ctx context.Context, vi *virtv2.VirtualImage) error {
	if mock.ValidateFunc == nil {
		panic("HandlerMock.ValidateFunc: method is nil but Handler.Validate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}{
		Ctx: ctx,
		Vi:  vi,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	return mock.ValidateFunc(ctx, vi)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//
//	len(mockedHandler.ValidateCalls())
func (mock *HandlerMock) ValidateCalls() []struct {
	Ctx context.Context
	Vi  *virtv2.VirtualImage
} {
	var calls []struct {
		Ctx context.Context
		Vi  *virtv2.VirtualImage
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}
