/*
Copyright 2025 Flant JSC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package internal

import (
	"context"
	"github.com/deckhouse/virtualization-controller/pkg/common/ip"
	virtv2 "github.com/deckhouse/virtualization/api/core/v1alpha2"
	"sync"
)

// Ensure, that IPAddressServiceMock does implement IPAddressService.
// If this is not the case, regenerate this file with moq.
var _ IPAddressService = &IPAddressServiceMock{}

// IPAddressServiceMock is a mock implementation of IPAddressService.
//
//	func TestSomethingThatUsesIPAddressService(t *testing.T) {
//
//		// make and configure a mocked IPAddressService
//		mockedIPAddressService := &IPAddressServiceMock{
//			AllocateNewIPFunc: func(allocatedIPs ip.AllocatedIPs) (string, error) {
//				panic("mock out the AllocateNewIP method")
//			},
//			GetAllocatedIPsFunc: func(ctx context.Context) (ip.AllocatedIPs, error) {
//				panic("mock out the GetAllocatedIPs method")
//			},
//			GetLeaseFunc: func(ctx context.Context, vmip *virtv2.VirtualMachineIPAddress) (*virtv2.VirtualMachineIPAddressLease, error) {
//				panic("mock out the GetLease method")
//			},
//			IsInsideOfRangeFunc: func(address string) error {
//				panic("mock out the IsInsideOfRange method")
//			},
//		}
//
//		// use mockedIPAddressService in code that requires IPAddressService
//		// and then make assertions.
//
//	}
type IPAddressServiceMock struct {
	// AllocateNewIPFunc mocks the AllocateNewIP method.
	AllocateNewIPFunc func(allocatedIPs ip.AllocatedIPs) (string, error)

	// GetAllocatedIPsFunc mocks the GetAllocatedIPs method.
	GetAllocatedIPsFunc func(ctx context.Context) (ip.AllocatedIPs, error)

	// GetLeaseFunc mocks the GetLease method.
	GetLeaseFunc func(ctx context.Context, vmip *virtv2.VirtualMachineIPAddress) (*virtv2.VirtualMachineIPAddressLease, error)

	// IsInsideOfRangeFunc mocks the IsInsideOfRange method.
	IsInsideOfRangeFunc func(address string) error

	// calls tracks calls to the methods.
	calls struct {
		// AllocateNewIP holds details about calls to the AllocateNewIP method.
		AllocateNewIP []struct {
			// AllocatedIPs is the allocatedIPs argument value.
			AllocatedIPs ip.AllocatedIPs
		}
		// GetAllocatedIPs holds details about calls to the GetAllocatedIPs method.
		GetAllocatedIPs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetLease holds details about calls to the GetLease method.
		GetLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vmip is the vmip argument value.
			Vmip *virtv2.VirtualMachineIPAddress
		}
		// IsInsideOfRange holds details about calls to the IsInsideOfRange method.
		IsInsideOfRange []struct {
			// Address is the address argument value.
			Address string
		}
	}
	lockAllocateNewIP   sync.RWMutex
	lockGetAllocatedIPs sync.RWMutex
	lockGetLease        sync.RWMutex
	lockIsInsideOfRange sync.RWMutex
}

// AllocateNewIP calls AllocateNewIPFunc.
func (mock *IPAddressServiceMock) AllocateNewIP(allocatedIPs ip.AllocatedIPs) (string, error) {
	if mock.AllocateNewIPFunc == nil {
		panic("IPAddressServiceMock.AllocateNewIPFunc: method is nil but IPAddressService.AllocateNewIP was just called")
	}
	callInfo := struct {
		AllocatedIPs ip.AllocatedIPs
	}{
		AllocatedIPs: allocatedIPs,
	}
	mock.lockAllocateNewIP.Lock()
	mock.calls.AllocateNewIP = append(mock.calls.AllocateNewIP, callInfo)
	mock.lockAllocateNewIP.Unlock()
	return mock.AllocateNewIPFunc(allocatedIPs)
}

// AllocateNewIPCalls gets all the calls that were made to AllocateNewIP.
// Check the length with:
//
//	len(mockedIPAddressService.AllocateNewIPCalls())
func (mock *IPAddressServiceMock) AllocateNewIPCalls() []struct {
	AllocatedIPs ip.AllocatedIPs
} {
	var calls []struct {
		AllocatedIPs ip.AllocatedIPs
	}
	mock.lockAllocateNewIP.RLock()
	calls = mock.calls.AllocateNewIP
	mock.lockAllocateNewIP.RUnlock()
	return calls
}

// GetAllocatedIPs calls GetAllocatedIPsFunc.
func (mock *IPAddressServiceMock) GetAllocatedIPs(ctx context.Context) (ip.AllocatedIPs, error) {
	if mock.GetAllocatedIPsFunc == nil {
		panic("IPAddressServiceMock.GetAllocatedIPsFunc: method is nil but IPAddressService.GetAllocatedIPs was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllocatedIPs.Lock()
	mock.calls.GetAllocatedIPs = append(mock.calls.GetAllocatedIPs, callInfo)
	mock.lockGetAllocatedIPs.Unlock()
	return mock.GetAllocatedIPsFunc(ctx)
}

// GetAllocatedIPsCalls gets all the calls that were made to GetAllocatedIPs.
// Check the length with:
//
//	len(mockedIPAddressService.GetAllocatedIPsCalls())
func (mock *IPAddressServiceMock) GetAllocatedIPsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllocatedIPs.RLock()
	calls = mock.calls.GetAllocatedIPs
	mock.lockGetAllocatedIPs.RUnlock()
	return calls
}

// GetLease calls GetLeaseFunc.
func (mock *IPAddressServiceMock) GetLease(ctx context.Context, vmip *virtv2.VirtualMachineIPAddress) (*virtv2.VirtualMachineIPAddressLease, error) {
	if mock.GetLeaseFunc == nil {
		panic("IPAddressServiceMock.GetLeaseFunc: method is nil but IPAddressService.GetLease was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Vmip *virtv2.VirtualMachineIPAddress
	}{
		Ctx:  ctx,
		Vmip: vmip,
	}
	mock.lockGetLease.Lock()
	mock.calls.GetLease = append(mock.calls.GetLease, callInfo)
	mock.lockGetLease.Unlock()
	return mock.GetLeaseFunc(ctx, vmip)
}

// GetLeaseCalls gets all the calls that were made to GetLease.
// Check the length with:
//
//	len(mockedIPAddressService.GetLeaseCalls())
func (mock *IPAddressServiceMock) GetLeaseCalls() []struct {
	Ctx  context.Context
	Vmip *virtv2.VirtualMachineIPAddress
} {
	var calls []struct {
		Ctx  context.Context
		Vmip *virtv2.VirtualMachineIPAddress
	}
	mock.lockGetLease.RLock()
	calls = mock.calls.GetLease
	mock.lockGetLease.RUnlock()
	return calls
}

// IsInsideOfRange calls IsInsideOfRangeFunc.
func (mock *IPAddressServiceMock) IsInsideOfRange(address string) error {
	if mock.IsInsideOfRangeFunc == nil {
		panic("IPAddressServiceMock.IsInsideOfRangeFunc: method is nil but IPAddressService.IsInsideOfRange was just called")
	}
	callInfo := struct {
		Address string
	}{
		Address: address,
	}
	mock.lockIsInsideOfRange.Lock()
	mock.calls.IsInsideOfRange = append(mock.calls.IsInsideOfRange, callInfo)
	mock.lockIsInsideOfRange.Unlock()
	return mock.IsInsideOfRangeFunc(address)
}

// IsInsideOfRangeCalls gets all the calls that were made to IsInsideOfRange.
// Check the length with:
//
//	len(mockedIPAddressService.IsInsideOfRangeCalls())
func (mock *IPAddressServiceMock) IsInsideOfRangeCalls() []struct {
	Address string
} {
	var calls []struct {
		Address string
	}
	mock.lockIsInsideOfRange.RLock()
	calls = mock.calls.IsInsideOfRange
	mock.lockIsInsideOfRange.RUnlock()
	return calls
}
