// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package source

import (
	"context"
	"github.com/deckhouse/virtualization-controller/pkg/common/datasource"
	"github.com/deckhouse/virtualization-controller/pkg/controller/importer"
	"github.com/deckhouse/virtualization-controller/pkg/controller/service"
	"github.com/deckhouse/virtualization-controller/pkg/controller/supplements"
	"github.com/deckhouse/virtualization-controller/pkg/controller/uploader"
	virtv2 "github.com/deckhouse/virtualization/api/core/v1alpha2"
	corev1 "k8s.io/api/core/v1"
	netv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sync"
)

// Ensure, that ImporterMock does implement Importer.
// If this is not the case, regenerate this file with moq.
var _ Importer = &ImporterMock{}

// ImporterMock is a mock implementation of Importer.
//
//	func TestSomethingThatUsesImporter(t *testing.T) {
//
//		// make and configure a mocked Importer
//		mockedImporter := &ImporterMock{
//			CleanUpFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			DeletePodFunc: func(ctx context.Context, obj service.ObjectKind, controllerName string) (bool, error) {
//				panic("mock out the DeletePod method")
//			},
//			GetPodFunc: func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
//				panic("mock out the GetPod method")
//			},
//			GetPodSettingsWithPVCFunc: func(ownerRef *metav1.OwnerReference, sup *supplements.Generator, pvcName string, pvcNamespace string) *importer.PodSettings {
//				panic("mock out the GetPodSettingsWithPVC method")
//			},
//			ProtectFunc: func(ctx context.Context, pod *corev1.Pod) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, settings *importer.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle) error {
//				panic("mock out the Start method")
//			},
//			StartWithPodSettingFunc: func(ctx context.Context, settings *importer.Settings, sup *supplements.Generator, caBundle *datasource.CABundle, podSettings *importer.PodSettings) error {
//				panic("mock out the StartWithPodSetting method")
//			},
//			UnprotectFunc: func(ctx context.Context, pod *corev1.Pod) error {
//				panic("mock out the Unprotect method")
//			},
//		}
//
//		// use mockedImporter in code that requires Importer
//		// and then make assertions.
//
//	}
type ImporterMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// DeletePodFunc mocks the DeletePod method.
	DeletePodFunc func(ctx context.Context, obj service.ObjectKind, controllerName string) (bool, error)

	// GetPodFunc mocks the GetPod method.
	GetPodFunc func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error)

	// GetPodSettingsWithPVCFunc mocks the GetPodSettingsWithPVC method.
	GetPodSettingsWithPVCFunc func(ownerRef *metav1.OwnerReference, sup *supplements.Generator, pvcName string, pvcNamespace string) *importer.PodSettings

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, pod *corev1.Pod) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, settings *importer.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle) error

	// StartWithPodSettingFunc mocks the StartWithPodSetting method.
	StartWithPodSettingFunc func(ctx context.Context, settings *importer.Settings, sup *supplements.Generator, caBundle *datasource.CABundle, podSettings *importer.PodSettings) error

	// UnprotectFunc mocks the Unprotect method.
	UnprotectFunc func(ctx context.Context, pod *corev1.Pod) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// DeletePod holds details about calls to the DeletePod method.
		DeletePod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Obj is the obj argument value.
			Obj service.ObjectKind
			// ControllerName is the controllerName argument value.
			ControllerName string
		}
		// GetPod holds details about calls to the GetPod method.
		GetPod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetPodSettingsWithPVC holds details about calls to the GetPodSettingsWithPVC method.
		GetPodSettingsWithPVC []struct {
			// OwnerRef is the ownerRef argument value.
			OwnerRef *metav1.OwnerReference
			// Sup is the sup argument value.
			Sup *supplements.Generator
			// PvcName is the pvcName argument value.
			PvcName string
			// PvcNamespace is the pvcNamespace argument value.
			PvcNamespace string
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *importer.Settings
			// Obj is the obj argument value.
			Obj service.ObjectKind
			// Sup is the sup argument value.
			Sup *supplements.Generator
			// CaBundle is the caBundle argument value.
			CaBundle *datasource.CABundle
		}
		// StartWithPodSetting holds details about calls to the StartWithPodSetting method.
		StartWithPodSetting []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *importer.Settings
			// Sup is the sup argument value.
			Sup *supplements.Generator
			// CaBundle is the caBundle argument value.
			CaBundle *datasource.CABundle
			// PodSettings is the podSettings argument value.
			PodSettings *importer.PodSettings
		}
		// Unprotect holds details about calls to the Unprotect method.
		Unprotect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
	}
	lockCleanUp               sync.RWMutex
	lockCleanUpSupplements    sync.RWMutex
	lockDeletePod             sync.RWMutex
	lockGetPod                sync.RWMutex
	lockGetPodSettingsWithPVC sync.RWMutex
	lockProtect               sync.RWMutex
	lockStart                 sync.RWMutex
	lockStartWithPodSetting   sync.RWMutex
	lockUnprotect             sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *ImporterMock) CleanUp(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("ImporterMock.CleanUpFunc: method is nil but Importer.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedImporter.CleanUpCalls())
func (mock *ImporterMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *ImporterMock) CleanUpSupplements(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("ImporterMock.CleanUpSupplementsFunc: method is nil but Importer.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedImporter.CleanUpSupplementsCalls())
func (mock *ImporterMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// DeletePod calls DeletePodFunc.
func (mock *ImporterMock) DeletePod(ctx context.Context, obj service.ObjectKind, controllerName string) (bool, error) {
	if mock.DeletePodFunc == nil {
		panic("ImporterMock.DeletePodFunc: method is nil but Importer.DeletePod was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Obj            service.ObjectKind
		ControllerName string
	}{
		Ctx:            ctx,
		Obj:            obj,
		ControllerName: controllerName,
	}
	mock.lockDeletePod.Lock()
	mock.calls.DeletePod = append(mock.calls.DeletePod, callInfo)
	mock.lockDeletePod.Unlock()
	return mock.DeletePodFunc(ctx, obj, controllerName)
}

// DeletePodCalls gets all the calls that were made to DeletePod.
// Check the length with:
//
//	len(mockedImporter.DeletePodCalls())
func (mock *ImporterMock) DeletePodCalls() []struct {
	Ctx            context.Context
	Obj            service.ObjectKind
	ControllerName string
} {
	var calls []struct {
		Ctx            context.Context
		Obj            service.ObjectKind
		ControllerName string
	}
	mock.lockDeletePod.RLock()
	calls = mock.calls.DeletePod
	mock.lockDeletePod.RUnlock()
	return calls
}

// GetPod calls GetPodFunc.
func (mock *ImporterMock) GetPod(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
	if mock.GetPodFunc == nil {
		panic("ImporterMock.GetPodFunc: method is nil but Importer.GetPod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetPod.Lock()
	mock.calls.GetPod = append(mock.calls.GetPod, callInfo)
	mock.lockGetPod.Unlock()
	return mock.GetPodFunc(ctx, sup)
}

// GetPodCalls gets all the calls that were made to GetPod.
// Check the length with:
//
//	len(mockedImporter.GetPodCalls())
func (mock *ImporterMock) GetPodCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetPod.RLock()
	calls = mock.calls.GetPod
	mock.lockGetPod.RUnlock()
	return calls
}

// GetPodSettingsWithPVC calls GetPodSettingsWithPVCFunc.
func (mock *ImporterMock) GetPodSettingsWithPVC(ownerRef *metav1.OwnerReference, sup *supplements.Generator, pvcName string, pvcNamespace string) *importer.PodSettings {
	if mock.GetPodSettingsWithPVCFunc == nil {
		panic("ImporterMock.GetPodSettingsWithPVCFunc: method is nil but Importer.GetPodSettingsWithPVC was just called")
	}
	callInfo := struct {
		OwnerRef     *metav1.OwnerReference
		Sup          *supplements.Generator
		PvcName      string
		PvcNamespace string
	}{
		OwnerRef:     ownerRef,
		Sup:          sup,
		PvcName:      pvcName,
		PvcNamespace: pvcNamespace,
	}
	mock.lockGetPodSettingsWithPVC.Lock()
	mock.calls.GetPodSettingsWithPVC = append(mock.calls.GetPodSettingsWithPVC, callInfo)
	mock.lockGetPodSettingsWithPVC.Unlock()
	return mock.GetPodSettingsWithPVCFunc(ownerRef, sup, pvcName, pvcNamespace)
}

// GetPodSettingsWithPVCCalls gets all the calls that were made to GetPodSettingsWithPVC.
// Check the length with:
//
//	len(mockedImporter.GetPodSettingsWithPVCCalls())
func (mock *ImporterMock) GetPodSettingsWithPVCCalls() []struct {
	OwnerRef     *metav1.OwnerReference
	Sup          *supplements.Generator
	PvcName      string
	PvcNamespace string
} {
	var calls []struct {
		OwnerRef     *metav1.OwnerReference
		Sup          *supplements.Generator
		PvcName      string
		PvcNamespace string
	}
	mock.lockGetPodSettingsWithPVC.RLock()
	calls = mock.calls.GetPodSettingsWithPVC
	mock.lockGetPodSettingsWithPVC.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *ImporterMock) Protect(ctx context.Context, pod *corev1.Pod) error {
	if mock.ProtectFunc == nil {
		panic("ImporterMock.ProtectFunc: method is nil but Importer.Protect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
	}{
		Ctx: ctx,
		Pod: pod,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, pod)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedImporter.ProtectCalls())
func (mock *ImporterMock) ProtectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *ImporterMock) Start(ctx context.Context, settings *importer.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle) error {
	if mock.StartFunc == nil {
		panic("ImporterMock.StartFunc: method is nil but Importer.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Settings *importer.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
	}{
		Ctx:      ctx,
		Settings: settings,
		Obj:      obj,
		Sup:      sup,
		CaBundle: caBundle,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, settings, obj, sup, caBundle)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedImporter.StartCalls())
func (mock *ImporterMock) StartCalls() []struct {
	Ctx      context.Context
	Settings *importer.Settings
	Obj      service.ObjectKind
	Sup      *supplements.Generator
	CaBundle *datasource.CABundle
} {
	var calls []struct {
		Ctx      context.Context
		Settings *importer.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// StartWithPodSetting calls StartWithPodSettingFunc.
func (mock *ImporterMock) StartWithPodSetting(ctx context.Context, settings *importer.Settings, sup *supplements.Generator, caBundle *datasource.CABundle, podSettings *importer.PodSettings) error {
	if mock.StartWithPodSettingFunc == nil {
		panic("ImporterMock.StartWithPodSettingFunc: method is nil but Importer.StartWithPodSetting was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Settings    *importer.Settings
		Sup         *supplements.Generator
		CaBundle    *datasource.CABundle
		PodSettings *importer.PodSettings
	}{
		Ctx:         ctx,
		Settings:    settings,
		Sup:         sup,
		CaBundle:    caBundle,
		PodSettings: podSettings,
	}
	mock.lockStartWithPodSetting.Lock()
	mock.calls.StartWithPodSetting = append(mock.calls.StartWithPodSetting, callInfo)
	mock.lockStartWithPodSetting.Unlock()
	return mock.StartWithPodSettingFunc(ctx, settings, sup, caBundle, podSettings)
}

// StartWithPodSettingCalls gets all the calls that were made to StartWithPodSetting.
// Check the length with:
//
//	len(mockedImporter.StartWithPodSettingCalls())
func (mock *ImporterMock) StartWithPodSettingCalls() []struct {
	Ctx         context.Context
	Settings    *importer.Settings
	Sup         *supplements.Generator
	CaBundle    *datasource.CABundle
	PodSettings *importer.PodSettings
} {
	var calls []struct {
		Ctx         context.Context
		Settings    *importer.Settings
		Sup         *supplements.Generator
		CaBundle    *datasource.CABundle
		PodSettings *importer.PodSettings
	}
	mock.lockStartWithPodSetting.RLock()
	calls = mock.calls.StartWithPodSetting
	mock.lockStartWithPodSetting.RUnlock()
	return calls
}

// Unprotect calls UnprotectFunc.
func (mock *ImporterMock) Unprotect(ctx context.Context, pod *corev1.Pod) error {
	if mock.UnprotectFunc == nil {
		panic("ImporterMock.UnprotectFunc: method is nil but Importer.Unprotect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
	}{
		Ctx: ctx,
		Pod: pod,
	}
	mock.lockUnprotect.Lock()
	mock.calls.Unprotect = append(mock.calls.Unprotect, callInfo)
	mock.lockUnprotect.Unlock()
	return mock.UnprotectFunc(ctx, pod)
}

// UnprotectCalls gets all the calls that were made to Unprotect.
// Check the length with:
//
//	len(mockedImporter.UnprotectCalls())
func (mock *ImporterMock) UnprotectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
	}
	mock.lockUnprotect.RLock()
	calls = mock.calls.Unprotect
	mock.lockUnprotect.RUnlock()
	return calls
}

// Ensure, that UploaderMock does implement Uploader.
// If this is not the case, regenerate this file with moq.
var _ Uploader = &UploaderMock{}

// UploaderMock is a mock implementation of Uploader.
//
//	func TestSomethingThatUsesUploader(t *testing.T) {
//
//		// make and configure a mocked Uploader
//		mockedUploader := &UploaderMock{
//			CleanUpFunc: func(ctx context.Context, sup *supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			GetIngressFunc: func(ctx context.Context, sup *supplements.Generator) (*netv1.Ingress, error) {
//				panic("mock out the GetIngress method")
//			},
//			GetPodFunc: func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
//				panic("mock out the GetPod method")
//			},
//			GetServiceFunc: func(ctx context.Context, sup *supplements.Generator) (*corev1.Service, error) {
//				panic("mock out the GetService method")
//			},
//			ProtectFunc: func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, settings *uploader.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle) error {
//				panic("mock out the Start method")
//			},
//			UnprotectFunc: func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
//				panic("mock out the Unprotect method")
//			},
//		}
//
//		// use mockedUploader in code that requires Uploader
//		// and then make assertions.
//
//	}
type UploaderMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup *supplements.Generator) (bool, error)

	// GetIngressFunc mocks the GetIngress method.
	GetIngressFunc func(ctx context.Context, sup *supplements.Generator) (*netv1.Ingress, error)

	// GetPodFunc mocks the GetPod method.
	GetPodFunc func(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error)

	// GetServiceFunc mocks the GetService method.
	GetServiceFunc func(ctx context.Context, sup *supplements.Generator) (*corev1.Service, error)

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, settings *uploader.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle) error

	// UnprotectFunc mocks the Unprotect method.
	UnprotectFunc func(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetIngress holds details about calls to the GetIngress method.
		GetIngress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetPod holds details about calls to the GetPod method.
		GetPod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// GetService holds details about calls to the GetService method.
		GetService []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup *supplements.Generator
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Settings is the settings argument value.
			Settings *uploader.Settings
			// Obj is the obj argument value.
			Obj service.ObjectKind
			// Sup is the sup argument value.
			Sup *supplements.Generator
			// CaBundle is the caBundle argument value.
			CaBundle *datasource.CABundle
		}
		// Unprotect holds details about calls to the Unprotect method.
		Unprotect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// Svc is the svc argument value.
			Svc *corev1.Service
			// Ing is the ing argument value.
			Ing *netv1.Ingress
		}
	}
	lockCleanUp    sync.RWMutex
	lockGetIngress sync.RWMutex
	lockGetPod     sync.RWMutex
	lockGetService sync.RWMutex
	lockProtect    sync.RWMutex
	lockStart      sync.RWMutex
	lockUnprotect  sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *UploaderMock) CleanUp(ctx context.Context, sup *supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("UploaderMock.CleanUpFunc: method is nil but Uploader.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedUploader.CleanUpCalls())
func (mock *UploaderMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// GetIngress calls GetIngressFunc.
func (mock *UploaderMock) GetIngress(ctx context.Context, sup *supplements.Generator) (*netv1.Ingress, error) {
	if mock.GetIngressFunc == nil {
		panic("UploaderMock.GetIngressFunc: method is nil but Uploader.GetIngress was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetIngress.Lock()
	mock.calls.GetIngress = append(mock.calls.GetIngress, callInfo)
	mock.lockGetIngress.Unlock()
	return mock.GetIngressFunc(ctx, sup)
}

// GetIngressCalls gets all the calls that were made to GetIngress.
// Check the length with:
//
//	len(mockedUploader.GetIngressCalls())
func (mock *UploaderMock) GetIngressCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetIngress.RLock()
	calls = mock.calls.GetIngress
	mock.lockGetIngress.RUnlock()
	return calls
}

// GetPod calls GetPodFunc.
func (mock *UploaderMock) GetPod(ctx context.Context, sup *supplements.Generator) (*corev1.Pod, error) {
	if mock.GetPodFunc == nil {
		panic("UploaderMock.GetPodFunc: method is nil but Uploader.GetPod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetPod.Lock()
	mock.calls.GetPod = append(mock.calls.GetPod, callInfo)
	mock.lockGetPod.Unlock()
	return mock.GetPodFunc(ctx, sup)
}

// GetPodCalls gets all the calls that were made to GetPod.
// Check the length with:
//
//	len(mockedUploader.GetPodCalls())
func (mock *UploaderMock) GetPodCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetPod.RLock()
	calls = mock.calls.GetPod
	mock.lockGetPod.RUnlock()
	return calls
}

// GetService calls GetServiceFunc.
func (mock *UploaderMock) GetService(ctx context.Context, sup *supplements.Generator) (*corev1.Service, error) {
	if mock.GetServiceFunc == nil {
		panic("UploaderMock.GetServiceFunc: method is nil but Uploader.GetService was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup *supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockGetService.Lock()
	mock.calls.GetService = append(mock.calls.GetService, callInfo)
	mock.lockGetService.Unlock()
	return mock.GetServiceFunc(ctx, sup)
}

// GetServiceCalls gets all the calls that were made to GetService.
// Check the length with:
//
//	len(mockedUploader.GetServiceCalls())
func (mock *UploaderMock) GetServiceCalls() []struct {
	Ctx context.Context
	Sup *supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup *supplements.Generator
	}
	mock.lockGetService.RLock()
	calls = mock.calls.GetService
	mock.lockGetService.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *UploaderMock) Protect(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
	if mock.ProtectFunc == nil {
		panic("UploaderMock.ProtectFunc: method is nil but Uploader.Protect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, pod, svc, ing)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedUploader.ProtectCalls())
func (mock *UploaderMock) ProtectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *UploaderMock) Start(ctx context.Context, settings *uploader.Settings, obj service.ObjectKind, sup *supplements.Generator, caBundle *datasource.CABundle) error {
	if mock.StartFunc == nil {
		panic("UploaderMock.StartFunc: method is nil but Uploader.Start was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Settings *uploader.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
	}{
		Ctx:      ctx,
		Settings: settings,
		Obj:      obj,
		Sup:      sup,
		CaBundle: caBundle,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, settings, obj, sup, caBundle)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedUploader.StartCalls())
func (mock *UploaderMock) StartCalls() []struct {
	Ctx      context.Context
	Settings *uploader.Settings
	Obj      service.ObjectKind
	Sup      *supplements.Generator
	CaBundle *datasource.CABundle
} {
	var calls []struct {
		Ctx      context.Context
		Settings *uploader.Settings
		Obj      service.ObjectKind
		Sup      *supplements.Generator
		CaBundle *datasource.CABundle
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Unprotect calls UnprotectFunc.
func (mock *UploaderMock) Unprotect(ctx context.Context, pod *corev1.Pod, svc *corev1.Service, ing *netv1.Ingress) error {
	if mock.UnprotectFunc == nil {
		panic("UploaderMock.UnprotectFunc: method is nil but Uploader.Unprotect was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}{
		Ctx: ctx,
		Pod: pod,
		Svc: svc,
		Ing: ing,
	}
	mock.lockUnprotect.Lock()
	mock.calls.Unprotect = append(mock.calls.Unprotect, callInfo)
	mock.lockUnprotect.Unlock()
	return mock.UnprotectFunc(ctx, pod, svc, ing)
}

// UnprotectCalls gets all the calls that were made to Unprotect.
// Check the length with:
//
//	len(mockedUploader.UnprotectCalls())
func (mock *UploaderMock) UnprotectCalls() []struct {
	Ctx context.Context
	Pod *corev1.Pod
	Svc *corev1.Service
	Ing *netv1.Ingress
} {
	var calls []struct {
		Ctx context.Context
		Pod *corev1.Pod
		Svc *corev1.Service
		Ing *netv1.Ingress
	}
	mock.lockUnprotect.RLock()
	calls = mock.calls.Unprotect
	mock.lockUnprotect.RUnlock()
	return calls
}

// Ensure, that StatMock does implement Stat.
// If this is not the case, regenerate this file with moq.
var _ Stat = &StatMock{}

// StatMock is a mock implementation of Stat.
//
//	func TestSomethingThatUsesStat(t *testing.T) {
//
//		// make and configure a mocked Stat
//		mockedStat := &StatMock{
//			CheckPodFunc: func(pod *corev1.Pod) error {
//				panic("mock out the CheckPod method")
//			},
//			GetCDROMFunc: func(pod *corev1.Pod) bool {
//				panic("mock out the GetCDROM method")
//			},
//			GetDVCRImageNameFunc: func(pod *corev1.Pod) string {
//				panic("mock out the GetDVCRImageName method")
//			},
//			GetDownloadSpeedFunc: func(ownerUID types.UID, pod *corev1.Pod) *virtv2.StatusSpeed {
//				panic("mock out the GetDownloadSpeed method")
//			},
//			GetFormatFunc: func(pod *corev1.Pod) string {
//				panic("mock out the GetFormat method")
//			},
//			GetProgressFunc: func(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string {
//				panic("mock out the GetProgress method")
//			},
//			GetSizeFunc: func(pod *corev1.Pod) virtv2.ImageStatusSize {
//				panic("mock out the GetSize method")
//			},
//			IsUploadStartedFunc: func(ownerUID types.UID, pod *corev1.Pod) bool {
//				panic("mock out the IsUploadStarted method")
//			},
//		}
//
//		// use mockedStat in code that requires Stat
//		// and then make assertions.
//
//	}
type StatMock struct {
	// CheckPodFunc mocks the CheckPod method.
	CheckPodFunc func(pod *corev1.Pod) error

	// GetCDROMFunc mocks the GetCDROM method.
	GetCDROMFunc func(pod *corev1.Pod) bool

	// GetDVCRImageNameFunc mocks the GetDVCRImageName method.
	GetDVCRImageNameFunc func(pod *corev1.Pod) string

	// GetDownloadSpeedFunc mocks the GetDownloadSpeed method.
	GetDownloadSpeedFunc func(ownerUID types.UID, pod *corev1.Pod) *virtv2.StatusSpeed

	// GetFormatFunc mocks the GetFormat method.
	GetFormatFunc func(pod *corev1.Pod) string

	// GetProgressFunc mocks the GetProgress method.
	GetProgressFunc func(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string

	// GetSizeFunc mocks the GetSize method.
	GetSizeFunc func(pod *corev1.Pod) virtv2.ImageStatusSize

	// IsUploadStartedFunc mocks the IsUploadStarted method.
	IsUploadStartedFunc func(ownerUID types.UID, pod *corev1.Pod) bool

	// calls tracks calls to the methods.
	calls struct {
		// CheckPod holds details about calls to the CheckPod method.
		CheckPod []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetCDROM holds details about calls to the GetCDROM method.
		GetCDROM []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetDVCRImageName holds details about calls to the GetDVCRImageName method.
		GetDVCRImageName []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetDownloadSpeed holds details about calls to the GetDownloadSpeed method.
		GetDownloadSpeed []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetFormat holds details about calls to the GetFormat method.
		GetFormat []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// GetProgress holds details about calls to the GetProgress method.
		GetProgress []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
			// PrevProgress is the prevProgress argument value.
			PrevProgress string
			// Opts is the opts argument value.
			Opts []service.GetProgressOption
		}
		// GetSize holds details about calls to the GetSize method.
		GetSize []struct {
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
		// IsUploadStarted holds details about calls to the IsUploadStarted method.
		IsUploadStarted []struct {
			// OwnerUID is the ownerUID argument value.
			OwnerUID types.UID
			// Pod is the pod argument value.
			Pod *corev1.Pod
		}
	}
	lockCheckPod         sync.RWMutex
	lockGetCDROM         sync.RWMutex
	lockGetDVCRImageName sync.RWMutex
	lockGetDownloadSpeed sync.RWMutex
	lockGetFormat        sync.RWMutex
	lockGetProgress      sync.RWMutex
	lockGetSize          sync.RWMutex
	lockIsUploadStarted  sync.RWMutex
}

// CheckPod calls CheckPodFunc.
func (mock *StatMock) CheckPod(pod *corev1.Pod) error {
	if mock.CheckPodFunc == nil {
		panic("StatMock.CheckPodFunc: method is nil but Stat.CheckPod was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockCheckPod.Lock()
	mock.calls.CheckPod = append(mock.calls.CheckPod, callInfo)
	mock.lockCheckPod.Unlock()
	return mock.CheckPodFunc(pod)
}

// CheckPodCalls gets all the calls that were made to CheckPod.
// Check the length with:
//
//	len(mockedStat.CheckPodCalls())
func (mock *StatMock) CheckPodCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockCheckPod.RLock()
	calls = mock.calls.CheckPod
	mock.lockCheckPod.RUnlock()
	return calls
}

// GetCDROM calls GetCDROMFunc.
func (mock *StatMock) GetCDROM(pod *corev1.Pod) bool {
	if mock.GetCDROMFunc == nil {
		panic("StatMock.GetCDROMFunc: method is nil but Stat.GetCDROM was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetCDROM.Lock()
	mock.calls.GetCDROM = append(mock.calls.GetCDROM, callInfo)
	mock.lockGetCDROM.Unlock()
	return mock.GetCDROMFunc(pod)
}

// GetCDROMCalls gets all the calls that were made to GetCDROM.
// Check the length with:
//
//	len(mockedStat.GetCDROMCalls())
func (mock *StatMock) GetCDROMCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetCDROM.RLock()
	calls = mock.calls.GetCDROM
	mock.lockGetCDROM.RUnlock()
	return calls
}

// GetDVCRImageName calls GetDVCRImageNameFunc.
func (mock *StatMock) GetDVCRImageName(pod *corev1.Pod) string {
	if mock.GetDVCRImageNameFunc == nil {
		panic("StatMock.GetDVCRImageNameFunc: method is nil but Stat.GetDVCRImageName was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetDVCRImageName.Lock()
	mock.calls.GetDVCRImageName = append(mock.calls.GetDVCRImageName, callInfo)
	mock.lockGetDVCRImageName.Unlock()
	return mock.GetDVCRImageNameFunc(pod)
}

// GetDVCRImageNameCalls gets all the calls that were made to GetDVCRImageName.
// Check the length with:
//
//	len(mockedStat.GetDVCRImageNameCalls())
func (mock *StatMock) GetDVCRImageNameCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetDVCRImageName.RLock()
	calls = mock.calls.GetDVCRImageName
	mock.lockGetDVCRImageName.RUnlock()
	return calls
}

// GetDownloadSpeed calls GetDownloadSpeedFunc.
func (mock *StatMock) GetDownloadSpeed(ownerUID types.UID, pod *corev1.Pod) *virtv2.StatusSpeed {
	if mock.GetDownloadSpeedFunc == nil {
		panic("StatMock.GetDownloadSpeedFunc: method is nil but Stat.GetDownloadSpeed was just called")
	}
	callInfo := struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}{
		OwnerUID: ownerUID,
		Pod:      pod,
	}
	mock.lockGetDownloadSpeed.Lock()
	mock.calls.GetDownloadSpeed = append(mock.calls.GetDownloadSpeed, callInfo)
	mock.lockGetDownloadSpeed.Unlock()
	return mock.GetDownloadSpeedFunc(ownerUID, pod)
}

// GetDownloadSpeedCalls gets all the calls that were made to GetDownloadSpeed.
// Check the length with:
//
//	len(mockedStat.GetDownloadSpeedCalls())
func (mock *StatMock) GetDownloadSpeedCalls() []struct {
	OwnerUID types.UID
	Pod      *corev1.Pod
} {
	var calls []struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}
	mock.lockGetDownloadSpeed.RLock()
	calls = mock.calls.GetDownloadSpeed
	mock.lockGetDownloadSpeed.RUnlock()
	return calls
}

// GetFormat calls GetFormatFunc.
func (mock *StatMock) GetFormat(pod *corev1.Pod) string {
	if mock.GetFormatFunc == nil {
		panic("StatMock.GetFormatFunc: method is nil but Stat.GetFormat was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetFormat.Lock()
	mock.calls.GetFormat = append(mock.calls.GetFormat, callInfo)
	mock.lockGetFormat.Unlock()
	return mock.GetFormatFunc(pod)
}

// GetFormatCalls gets all the calls that were made to GetFormat.
// Check the length with:
//
//	len(mockedStat.GetFormatCalls())
func (mock *StatMock) GetFormatCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetFormat.RLock()
	calls = mock.calls.GetFormat
	mock.lockGetFormat.RUnlock()
	return calls
}

// GetProgress calls GetProgressFunc.
func (mock *StatMock) GetProgress(ownerUID types.UID, pod *corev1.Pod, prevProgress string, opts ...service.GetProgressOption) string {
	if mock.GetProgressFunc == nil {
		panic("StatMock.GetProgressFunc: method is nil but Stat.GetProgress was just called")
	}
	callInfo := struct {
		OwnerUID     types.UID
		Pod          *corev1.Pod
		PrevProgress string
		Opts         []service.GetProgressOption
	}{
		OwnerUID:     ownerUID,
		Pod:          pod,
		PrevProgress: prevProgress,
		Opts:         opts,
	}
	mock.lockGetProgress.Lock()
	mock.calls.GetProgress = append(mock.calls.GetProgress, callInfo)
	mock.lockGetProgress.Unlock()
	return mock.GetProgressFunc(ownerUID, pod, prevProgress, opts...)
}

// GetProgressCalls gets all the calls that were made to GetProgress.
// Check the length with:
//
//	len(mockedStat.GetProgressCalls())
func (mock *StatMock) GetProgressCalls() []struct {
	OwnerUID     types.UID
	Pod          *corev1.Pod
	PrevProgress string
	Opts         []service.GetProgressOption
} {
	var calls []struct {
		OwnerUID     types.UID
		Pod          *corev1.Pod
		PrevProgress string
		Opts         []service.GetProgressOption
	}
	mock.lockGetProgress.RLock()
	calls = mock.calls.GetProgress
	mock.lockGetProgress.RUnlock()
	return calls
}

// GetSize calls GetSizeFunc.
func (mock *StatMock) GetSize(pod *corev1.Pod) virtv2.ImageStatusSize {
	if mock.GetSizeFunc == nil {
		panic("StatMock.GetSizeFunc: method is nil but Stat.GetSize was just called")
	}
	callInfo := struct {
		Pod *corev1.Pod
	}{
		Pod: pod,
	}
	mock.lockGetSize.Lock()
	mock.calls.GetSize = append(mock.calls.GetSize, callInfo)
	mock.lockGetSize.Unlock()
	return mock.GetSizeFunc(pod)
}

// GetSizeCalls gets all the calls that were made to GetSize.
// Check the length with:
//
//	len(mockedStat.GetSizeCalls())
func (mock *StatMock) GetSizeCalls() []struct {
	Pod *corev1.Pod
} {
	var calls []struct {
		Pod *corev1.Pod
	}
	mock.lockGetSize.RLock()
	calls = mock.calls.GetSize
	mock.lockGetSize.RUnlock()
	return calls
}

// IsUploadStarted calls IsUploadStartedFunc.
func (mock *StatMock) IsUploadStarted(ownerUID types.UID, pod *corev1.Pod) bool {
	if mock.IsUploadStartedFunc == nil {
		panic("StatMock.IsUploadStartedFunc: method is nil but Stat.IsUploadStarted was just called")
	}
	callInfo := struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}{
		OwnerUID: ownerUID,
		Pod:      pod,
	}
	mock.lockIsUploadStarted.Lock()
	mock.calls.IsUploadStarted = append(mock.calls.IsUploadStarted, callInfo)
	mock.lockIsUploadStarted.Unlock()
	return mock.IsUploadStartedFunc(ownerUID, pod)
}

// IsUploadStartedCalls gets all the calls that were made to IsUploadStarted.
// Check the length with:
//
//	len(mockedStat.IsUploadStartedCalls())
func (mock *StatMock) IsUploadStartedCalls() []struct {
	OwnerUID types.UID
	Pod      *corev1.Pod
} {
	var calls []struct {
		OwnerUID types.UID
		Pod      *corev1.Pod
	}
	mock.lockIsUploadStarted.RLock()
	calls = mock.calls.IsUploadStarted
	mock.lockIsUploadStarted.RUnlock()
	return calls
}
