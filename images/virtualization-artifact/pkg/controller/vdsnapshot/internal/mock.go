// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package internal

import (
	"context"
	"github.com/deckhouse/virtualization/api/core/v1alpha2"
	vsv1 "github.com/kubernetes-csi/external-snapshotter/client/v6/apis/volumesnapshot/v1"
	corev1 "k8s.io/api/core/v1"
	virtv1 "kubevirt.io/api/core/v1"
	"sync"
)

// Ensure, that VirtualDiskReadySnapshotterMock does implement VirtualDiskReadySnapshotter.
// If this is not the case, regenerate this file with moq.
var _ VirtualDiskReadySnapshotter = &VirtualDiskReadySnapshotterMock{}

// VirtualDiskReadySnapshotterMock is a mock implementation of VirtualDiskReadySnapshotter.
//
//	func TestSomethingThatUsesVirtualDiskReadySnapshotter(t *testing.T) {
//
//		// make and configure a mocked VirtualDiskReadySnapshotter
//		mockedVirtualDiskReadySnapshotter := &VirtualDiskReadySnapshotterMock{
//			GetVirtualDiskFunc: func(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualDisk, error) {
//				panic("mock out the GetVirtualDisk method")
//			},
//		}
//
//		// use mockedVirtualDiskReadySnapshotter in code that requires VirtualDiskReadySnapshotter
//		// and then make assertions.
//
//	}
type VirtualDiskReadySnapshotterMock struct {
	// GetVirtualDiskFunc mocks the GetVirtualDisk method.
	GetVirtualDiskFunc func(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualDisk, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetVirtualDisk holds details about calls to the GetVirtualDisk method.
		GetVirtualDisk []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace string
		}
	}
	lockGetVirtualDisk sync.RWMutex
}

// GetVirtualDisk calls GetVirtualDiskFunc.
func (mock *VirtualDiskReadySnapshotterMock) GetVirtualDisk(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualDisk, error) {
	if mock.GetVirtualDiskFunc == nil {
		panic("VirtualDiskReadySnapshotterMock.GetVirtualDiskFunc: method is nil but VirtualDiskReadySnapshotter.GetVirtualDisk was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}{
		Ctx:       ctx,
		Name:      name,
		Namespace: namespace,
	}
	mock.lockGetVirtualDisk.Lock()
	mock.calls.GetVirtualDisk = append(mock.calls.GetVirtualDisk, callInfo)
	mock.lockGetVirtualDisk.Unlock()
	return mock.GetVirtualDiskFunc(ctx, name, namespace)
}

// GetVirtualDiskCalls gets all the calls that were made to GetVirtualDisk.
// Check the length with:
//
//	len(mockedVirtualDiskReadySnapshotter.GetVirtualDiskCalls())
func (mock *VirtualDiskReadySnapshotterMock) GetVirtualDiskCalls() []struct {
	Ctx       context.Context
	Name      string
	Namespace string
} {
	var calls []struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}
	mock.lockGetVirtualDisk.RLock()
	calls = mock.calls.GetVirtualDisk
	mock.lockGetVirtualDisk.RUnlock()
	return calls
}

// Ensure, that LifeCycleSnapshotterMock does implement LifeCycleSnapshotter.
// If this is not the case, regenerate this file with moq.
var _ LifeCycleSnapshotter = &LifeCycleSnapshotterMock{}

// LifeCycleSnapshotterMock is a mock implementation of LifeCycleSnapshotter.
//
//	func TestSomethingThatUsesLifeCycleSnapshotter(t *testing.T) {
//
//		// make and configure a mocked LifeCycleSnapshotter
//		mockedLifeCycleSnapshotter := &LifeCycleSnapshotterMock{
//			CanFreezeFunc: func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) (bool, error) {
//				panic("mock out the CanFreeze method")
//			},
//			CanUnfreezeFunc: func(ctx context.Context, vdSnapshotName string, vm *v1alpha2.VirtualMachine, kvvmi *virtv1.VirtualMachineInstance) (bool, error) {
//				panic("mock out the CanUnfreeze method")
//			},
//			CreateVolumeSnapshotFunc: func(ctx context.Context, vs *vsv1.VolumeSnapshot) (*vsv1.VolumeSnapshot, error) {
//				panic("mock out the CreateVolumeSnapshot method")
//			},
//			FreezeFunc: func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error {
//				panic("mock out the Freeze method")
//			},
//			GetKubeVirtVirtualMachineInstanceFunc: func(ctx context.Context, vm *v1alpha2.VirtualMachine) (*virtv1.VirtualMachineInstance, error) {
//				panic("mock out the GetKubeVirtVirtualMachineInstance method")
//			},
//			GetPersistentVolumeClaimFunc: func(ctx context.Context, name string, namespace string) (*corev1.PersistentVolumeClaim, error) {
//				panic("mock out the GetPersistentVolumeClaim method")
//			},
//			GetVirtualDiskFunc: func(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualDisk, error) {
//				panic("mock out the GetVirtualDisk method")
//			},
//			GetVirtualMachineFunc: func(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualMachine, error) {
//				panic("mock out the GetVirtualMachine method")
//			},
//			GetVolumeSnapshotFunc: func(ctx context.Context, name string, namespace string) (*vsv1.VolumeSnapshot, error) {
//				panic("mock out the GetVolumeSnapshot method")
//			},
//			IsFrozenFunc: func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) (bool, error) {
//				panic("mock out the IsFrozen method")
//			},
//			SyncFSFreezeRequestFunc: func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error {
//				panic("mock out the SyncFSFreezeRequest method")
//			},
//			UnfreezeFunc: func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error {
//				panic("mock out the Unfreeze method")
//			},
//		}
//
//		// use mockedLifeCycleSnapshotter in code that requires LifeCycleSnapshotter
//		// and then make assertions.
//
//	}
type LifeCycleSnapshotterMock struct {
	// CanFreezeFunc mocks the CanFreeze method.
	CanFreezeFunc func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) (bool, error)

	// CanUnfreezeFunc mocks the CanUnfreeze method.
	CanUnfreezeFunc func(ctx context.Context, vdSnapshotName string, vm *v1alpha2.VirtualMachine, kvvmi *virtv1.VirtualMachineInstance) (bool, error)

	// CreateVolumeSnapshotFunc mocks the CreateVolumeSnapshot method.
	CreateVolumeSnapshotFunc func(ctx context.Context, vs *vsv1.VolumeSnapshot) (*vsv1.VolumeSnapshot, error)

	// FreezeFunc mocks the Freeze method.
	FreezeFunc func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error

	// GetKubeVirtVirtualMachineInstanceFunc mocks the GetKubeVirtVirtualMachineInstance method.
	GetKubeVirtVirtualMachineInstanceFunc func(ctx context.Context, vm *v1alpha2.VirtualMachine) (*virtv1.VirtualMachineInstance, error)

	// GetPersistentVolumeClaimFunc mocks the GetPersistentVolumeClaim method.
	GetPersistentVolumeClaimFunc func(ctx context.Context, name string, namespace string) (*corev1.PersistentVolumeClaim, error)

	// GetVirtualDiskFunc mocks the GetVirtualDisk method.
	GetVirtualDiskFunc func(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualDisk, error)

	// GetVirtualMachineFunc mocks the GetVirtualMachine method.
	GetVirtualMachineFunc func(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualMachine, error)

	// GetVolumeSnapshotFunc mocks the GetVolumeSnapshot method.
	GetVolumeSnapshotFunc func(ctx context.Context, name string, namespace string) (*vsv1.VolumeSnapshot, error)

	// IsFrozenFunc mocks the IsFrozen method.
	IsFrozenFunc func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) (bool, error)

	// SyncFSFreezeRequestFunc mocks the SyncFSFreezeRequest method.
	SyncFSFreezeRequestFunc func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error

	// UnfreezeFunc mocks the Unfreeze method.
	UnfreezeFunc func(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error

	// calls tracks calls to the methods.
	calls struct {
		// CanFreeze holds details about calls to the CanFreeze method.
		CanFreeze []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kvvmi is the kvvmi argument value.
			Kvvmi *virtv1.VirtualMachineInstance
		}
		// CanUnfreeze holds details about calls to the CanUnfreeze method.
		CanUnfreeze []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// VdSnapshotName is the vdSnapshotName argument value.
			VdSnapshotName string
			// VM is the vm argument value.
			VM *v1alpha2.VirtualMachine
			// Kvvmi is the kvvmi argument value.
			Kvvmi *virtv1.VirtualMachineInstance
		}
		// CreateVolumeSnapshot holds details about calls to the CreateVolumeSnapshot method.
		CreateVolumeSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vs is the vs argument value.
			Vs *vsv1.VolumeSnapshot
		}
		// Freeze holds details about calls to the Freeze method.
		Freeze []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kvvmi is the kvvmi argument value.
			Kvvmi *virtv1.VirtualMachineInstance
		}
		// GetKubeVirtVirtualMachineInstance holds details about calls to the GetKubeVirtVirtualMachineInstance method.
		GetKubeVirtVirtualMachineInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// VM is the vm argument value.
			VM *v1alpha2.VirtualMachine
		}
		// GetPersistentVolumeClaim holds details about calls to the GetPersistentVolumeClaim method.
		GetPersistentVolumeClaim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace string
		}
		// GetVirtualDisk holds details about calls to the GetVirtualDisk method.
		GetVirtualDisk []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace string
		}
		// GetVirtualMachine holds details about calls to the GetVirtualMachine method.
		GetVirtualMachine []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace string
		}
		// GetVolumeSnapshot holds details about calls to the GetVolumeSnapshot method.
		GetVolumeSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Namespace is the namespace argument value.
			Namespace string
		}
		// IsFrozen holds details about calls to the IsFrozen method.
		IsFrozen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kvvmi is the kvvmi argument value.
			Kvvmi *virtv1.VirtualMachineInstance
		}
		// SyncFSFreezeRequest holds details about calls to the SyncFSFreezeRequest method.
		SyncFSFreezeRequest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kvvmi is the kvvmi argument value.
			Kvvmi *virtv1.VirtualMachineInstance
		}
		// Unfreeze holds details about calls to the Unfreeze method.
		Unfreeze []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Kvvmi is the kvvmi argument value.
			Kvvmi *virtv1.VirtualMachineInstance
		}
	}
	lockCanFreeze                         sync.RWMutex
	lockCanUnfreeze                       sync.RWMutex
	lockCreateVolumeSnapshot              sync.RWMutex
	lockFreeze                            sync.RWMutex
	lockGetKubeVirtVirtualMachineInstance sync.RWMutex
	lockGetPersistentVolumeClaim          sync.RWMutex
	lockGetVirtualDisk                    sync.RWMutex
	lockGetVirtualMachine                 sync.RWMutex
	lockGetVolumeSnapshot                 sync.RWMutex
	lockIsFrozen                          sync.RWMutex
	lockSyncFSFreezeRequest               sync.RWMutex
	lockUnfreeze                          sync.RWMutex
}

// CanFreeze calls CanFreezeFunc.
func (mock *LifeCycleSnapshotterMock) CanFreeze(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) (bool, error) {
	if mock.CanFreezeFunc == nil {
		panic("LifeCycleSnapshotterMock.CanFreezeFunc: method is nil but LifeCycleSnapshotter.CanFreeze was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}{
		Ctx:   ctx,
		Kvvmi: kvvmi,
	}
	mock.lockCanFreeze.Lock()
	mock.calls.CanFreeze = append(mock.calls.CanFreeze, callInfo)
	mock.lockCanFreeze.Unlock()
	return mock.CanFreezeFunc(ctx, kvvmi)
}

// CanFreezeCalls gets all the calls that were made to CanFreeze.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.CanFreezeCalls())
func (mock *LifeCycleSnapshotterMock) CanFreezeCalls() []struct {
	Ctx   context.Context
	Kvvmi *virtv1.VirtualMachineInstance
} {
	var calls []struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}
	mock.lockCanFreeze.RLock()
	calls = mock.calls.CanFreeze
	mock.lockCanFreeze.RUnlock()
	return calls
}

// CanUnfreeze calls CanUnfreezeFunc.
func (mock *LifeCycleSnapshotterMock) CanUnfreeze(ctx context.Context, vdSnapshotName string, vm *v1alpha2.VirtualMachine, kvvmi *virtv1.VirtualMachineInstance) (bool, error) {
	if mock.CanUnfreezeFunc == nil {
		panic("LifeCycleSnapshotterMock.CanUnfreezeFunc: method is nil but LifeCycleSnapshotter.CanUnfreeze was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		VdSnapshotName string
		VM             *v1alpha2.VirtualMachine
		Kvvmi          *virtv1.VirtualMachineInstance
	}{
		Ctx:            ctx,
		VdSnapshotName: vdSnapshotName,
		VM:             vm,
		Kvvmi:          kvvmi,
	}
	mock.lockCanUnfreeze.Lock()
	mock.calls.CanUnfreeze = append(mock.calls.CanUnfreeze, callInfo)
	mock.lockCanUnfreeze.Unlock()
	return mock.CanUnfreezeFunc(ctx, vdSnapshotName, vm, kvvmi)
}

// CanUnfreezeCalls gets all the calls that were made to CanUnfreeze.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.CanUnfreezeCalls())
func (mock *LifeCycleSnapshotterMock) CanUnfreezeCalls() []struct {
	Ctx            context.Context
	VdSnapshotName string
	VM             *v1alpha2.VirtualMachine
	Kvvmi          *virtv1.VirtualMachineInstance
} {
	var calls []struct {
		Ctx            context.Context
		VdSnapshotName string
		VM             *v1alpha2.VirtualMachine
		Kvvmi          *virtv1.VirtualMachineInstance
	}
	mock.lockCanUnfreeze.RLock()
	calls = mock.calls.CanUnfreeze
	mock.lockCanUnfreeze.RUnlock()
	return calls
}

// CreateVolumeSnapshot calls CreateVolumeSnapshotFunc.
func (mock *LifeCycleSnapshotterMock) CreateVolumeSnapshot(ctx context.Context, vs *vsv1.VolumeSnapshot) (*vsv1.VolumeSnapshot, error) {
	if mock.CreateVolumeSnapshotFunc == nil {
		panic("LifeCycleSnapshotterMock.CreateVolumeSnapshotFunc: method is nil but LifeCycleSnapshotter.CreateVolumeSnapshot was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vs  *vsv1.VolumeSnapshot
	}{
		Ctx: ctx,
		Vs:  vs,
	}
	mock.lockCreateVolumeSnapshot.Lock()
	mock.calls.CreateVolumeSnapshot = append(mock.calls.CreateVolumeSnapshot, callInfo)
	mock.lockCreateVolumeSnapshot.Unlock()
	return mock.CreateVolumeSnapshotFunc(ctx, vs)
}

// CreateVolumeSnapshotCalls gets all the calls that were made to CreateVolumeSnapshot.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.CreateVolumeSnapshotCalls())
func (mock *LifeCycleSnapshotterMock) CreateVolumeSnapshotCalls() []struct {
	Ctx context.Context
	Vs  *vsv1.VolumeSnapshot
} {
	var calls []struct {
		Ctx context.Context
		Vs  *vsv1.VolumeSnapshot
	}
	mock.lockCreateVolumeSnapshot.RLock()
	calls = mock.calls.CreateVolumeSnapshot
	mock.lockCreateVolumeSnapshot.RUnlock()
	return calls
}

// Freeze calls FreezeFunc.
func (mock *LifeCycleSnapshotterMock) Freeze(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error {
	if mock.FreezeFunc == nil {
		panic("LifeCycleSnapshotterMock.FreezeFunc: method is nil but LifeCycleSnapshotter.Freeze was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}{
		Ctx:   ctx,
		Kvvmi: kvvmi,
	}
	mock.lockFreeze.Lock()
	mock.calls.Freeze = append(mock.calls.Freeze, callInfo)
	mock.lockFreeze.Unlock()
	return mock.FreezeFunc(ctx, kvvmi)
}

// FreezeCalls gets all the calls that were made to Freeze.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.FreezeCalls())
func (mock *LifeCycleSnapshotterMock) FreezeCalls() []struct {
	Ctx   context.Context
	Kvvmi *virtv1.VirtualMachineInstance
} {
	var calls []struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}
	mock.lockFreeze.RLock()
	calls = mock.calls.Freeze
	mock.lockFreeze.RUnlock()
	return calls
}

// GetKubeVirtVirtualMachineInstance calls GetKubeVirtVirtualMachineInstanceFunc.
func (mock *LifeCycleSnapshotterMock) GetKubeVirtVirtualMachineInstance(ctx context.Context, vm *v1alpha2.VirtualMachine) (*virtv1.VirtualMachineInstance, error) {
	if mock.GetKubeVirtVirtualMachineInstanceFunc == nil {
		panic("LifeCycleSnapshotterMock.GetKubeVirtVirtualMachineInstanceFunc: method is nil but LifeCycleSnapshotter.GetKubeVirtVirtualMachineInstance was just called")
	}
	callInfo := struct {
		Ctx context.Context
		VM  *v1alpha2.VirtualMachine
	}{
		Ctx: ctx,
		VM:  vm,
	}
	mock.lockGetKubeVirtVirtualMachineInstance.Lock()
	mock.calls.GetKubeVirtVirtualMachineInstance = append(mock.calls.GetKubeVirtVirtualMachineInstance, callInfo)
	mock.lockGetKubeVirtVirtualMachineInstance.Unlock()
	return mock.GetKubeVirtVirtualMachineInstanceFunc(ctx, vm)
}

// GetKubeVirtVirtualMachineInstanceCalls gets all the calls that were made to GetKubeVirtVirtualMachineInstance.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.GetKubeVirtVirtualMachineInstanceCalls())
func (mock *LifeCycleSnapshotterMock) GetKubeVirtVirtualMachineInstanceCalls() []struct {
	Ctx context.Context
	VM  *v1alpha2.VirtualMachine
} {
	var calls []struct {
		Ctx context.Context
		VM  *v1alpha2.VirtualMachine
	}
	mock.lockGetKubeVirtVirtualMachineInstance.RLock()
	calls = mock.calls.GetKubeVirtVirtualMachineInstance
	mock.lockGetKubeVirtVirtualMachineInstance.RUnlock()
	return calls
}

// GetPersistentVolumeClaim calls GetPersistentVolumeClaimFunc.
func (mock *LifeCycleSnapshotterMock) GetPersistentVolumeClaim(ctx context.Context, name string, namespace string) (*corev1.PersistentVolumeClaim, error) {
	if mock.GetPersistentVolumeClaimFunc == nil {
		panic("LifeCycleSnapshotterMock.GetPersistentVolumeClaimFunc: method is nil but LifeCycleSnapshotter.GetPersistentVolumeClaim was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}{
		Ctx:       ctx,
		Name:      name,
		Namespace: namespace,
	}
	mock.lockGetPersistentVolumeClaim.Lock()
	mock.calls.GetPersistentVolumeClaim = append(mock.calls.GetPersistentVolumeClaim, callInfo)
	mock.lockGetPersistentVolumeClaim.Unlock()
	return mock.GetPersistentVolumeClaimFunc(ctx, name, namespace)
}

// GetPersistentVolumeClaimCalls gets all the calls that were made to GetPersistentVolumeClaim.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.GetPersistentVolumeClaimCalls())
func (mock *LifeCycleSnapshotterMock) GetPersistentVolumeClaimCalls() []struct {
	Ctx       context.Context
	Name      string
	Namespace string
} {
	var calls []struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}
	mock.lockGetPersistentVolumeClaim.RLock()
	calls = mock.calls.GetPersistentVolumeClaim
	mock.lockGetPersistentVolumeClaim.RUnlock()
	return calls
}

// GetVirtualDisk calls GetVirtualDiskFunc.
func (mock *LifeCycleSnapshotterMock) GetVirtualDisk(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualDisk, error) {
	if mock.GetVirtualDiskFunc == nil {
		panic("LifeCycleSnapshotterMock.GetVirtualDiskFunc: method is nil but LifeCycleSnapshotter.GetVirtualDisk was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}{
		Ctx:       ctx,
		Name:      name,
		Namespace: namespace,
	}
	mock.lockGetVirtualDisk.Lock()
	mock.calls.GetVirtualDisk = append(mock.calls.GetVirtualDisk, callInfo)
	mock.lockGetVirtualDisk.Unlock()
	return mock.GetVirtualDiskFunc(ctx, name, namespace)
}

// GetVirtualDiskCalls gets all the calls that were made to GetVirtualDisk.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.GetVirtualDiskCalls())
func (mock *LifeCycleSnapshotterMock) GetVirtualDiskCalls() []struct {
	Ctx       context.Context
	Name      string
	Namespace string
} {
	var calls []struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}
	mock.lockGetVirtualDisk.RLock()
	calls = mock.calls.GetVirtualDisk
	mock.lockGetVirtualDisk.RUnlock()
	return calls
}

// GetVirtualMachine calls GetVirtualMachineFunc.
func (mock *LifeCycleSnapshotterMock) GetVirtualMachine(ctx context.Context, name string, namespace string) (*v1alpha2.VirtualMachine, error) {
	if mock.GetVirtualMachineFunc == nil {
		panic("LifeCycleSnapshotterMock.GetVirtualMachineFunc: method is nil but LifeCycleSnapshotter.GetVirtualMachine was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}{
		Ctx:       ctx,
		Name:      name,
		Namespace: namespace,
	}
	mock.lockGetVirtualMachine.Lock()
	mock.calls.GetVirtualMachine = append(mock.calls.GetVirtualMachine, callInfo)
	mock.lockGetVirtualMachine.Unlock()
	return mock.GetVirtualMachineFunc(ctx, name, namespace)
}

// GetVirtualMachineCalls gets all the calls that were made to GetVirtualMachine.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.GetVirtualMachineCalls())
func (mock *LifeCycleSnapshotterMock) GetVirtualMachineCalls() []struct {
	Ctx       context.Context
	Name      string
	Namespace string
} {
	var calls []struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}
	mock.lockGetVirtualMachine.RLock()
	calls = mock.calls.GetVirtualMachine
	mock.lockGetVirtualMachine.RUnlock()
	return calls
}

// GetVolumeSnapshot calls GetVolumeSnapshotFunc.
func (mock *LifeCycleSnapshotterMock) GetVolumeSnapshot(ctx context.Context, name string, namespace string) (*vsv1.VolumeSnapshot, error) {
	if mock.GetVolumeSnapshotFunc == nil {
		panic("LifeCycleSnapshotterMock.GetVolumeSnapshotFunc: method is nil but LifeCycleSnapshotter.GetVolumeSnapshot was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}{
		Ctx:       ctx,
		Name:      name,
		Namespace: namespace,
	}
	mock.lockGetVolumeSnapshot.Lock()
	mock.calls.GetVolumeSnapshot = append(mock.calls.GetVolumeSnapshot, callInfo)
	mock.lockGetVolumeSnapshot.Unlock()
	return mock.GetVolumeSnapshotFunc(ctx, name, namespace)
}

// GetVolumeSnapshotCalls gets all the calls that were made to GetVolumeSnapshot.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.GetVolumeSnapshotCalls())
func (mock *LifeCycleSnapshotterMock) GetVolumeSnapshotCalls() []struct {
	Ctx       context.Context
	Name      string
	Namespace string
} {
	var calls []struct {
		Ctx       context.Context
		Name      string
		Namespace string
	}
	mock.lockGetVolumeSnapshot.RLock()
	calls = mock.calls.GetVolumeSnapshot
	mock.lockGetVolumeSnapshot.RUnlock()
	return calls
}

// IsFrozen calls IsFrozenFunc.
func (mock *LifeCycleSnapshotterMock) IsFrozen(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) (bool, error) {
	if mock.IsFrozenFunc == nil {
		panic("LifeCycleSnapshotterMock.IsFrozenFunc: method is nil but LifeCycleSnapshotter.IsFrozen was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}{
		Ctx:   ctx,
		Kvvmi: kvvmi,
	}
	mock.lockIsFrozen.Lock()
	mock.calls.IsFrozen = append(mock.calls.IsFrozen, callInfo)
	mock.lockIsFrozen.Unlock()
	return mock.IsFrozenFunc(ctx, kvvmi)
}

// IsFrozenCalls gets all the calls that were made to IsFrozen.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.IsFrozenCalls())
func (mock *LifeCycleSnapshotterMock) IsFrozenCalls() []struct {
	Ctx   context.Context
	Kvvmi *virtv1.VirtualMachineInstance
} {
	var calls []struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}
	mock.lockIsFrozen.RLock()
	calls = mock.calls.IsFrozen
	mock.lockIsFrozen.RUnlock()
	return calls
}

// SyncFSFreezeRequest calls SyncFSFreezeRequestFunc.
func (mock *LifeCycleSnapshotterMock) SyncFSFreezeRequest(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error {
	if mock.SyncFSFreezeRequestFunc == nil {
		panic("LifeCycleSnapshotterMock.SyncFSFreezeRequestFunc: method is nil but LifeCycleSnapshotter.SyncFSFreezeRequest was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}{
		Ctx:   ctx,
		Kvvmi: kvvmi,
	}
	mock.lockSyncFSFreezeRequest.Lock()
	mock.calls.SyncFSFreezeRequest = append(mock.calls.SyncFSFreezeRequest, callInfo)
	mock.lockSyncFSFreezeRequest.Unlock()
	return mock.SyncFSFreezeRequestFunc(ctx, kvvmi)
}

// SyncFSFreezeRequestCalls gets all the calls that were made to SyncFSFreezeRequest.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.SyncFSFreezeRequestCalls())
func (mock *LifeCycleSnapshotterMock) SyncFSFreezeRequestCalls() []struct {
	Ctx   context.Context
	Kvvmi *virtv1.VirtualMachineInstance
} {
	var calls []struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}
	mock.lockSyncFSFreezeRequest.RLock()
	calls = mock.calls.SyncFSFreezeRequest
	mock.lockSyncFSFreezeRequest.RUnlock()
	return calls
}

// Unfreeze calls UnfreezeFunc.
func (mock *LifeCycleSnapshotterMock) Unfreeze(ctx context.Context, kvvmi *virtv1.VirtualMachineInstance) error {
	if mock.UnfreezeFunc == nil {
		panic("LifeCycleSnapshotterMock.UnfreezeFunc: method is nil but LifeCycleSnapshotter.Unfreeze was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}{
		Ctx:   ctx,
		Kvvmi: kvvmi,
	}
	mock.lockUnfreeze.Lock()
	mock.calls.Unfreeze = append(mock.calls.Unfreeze, callInfo)
	mock.lockUnfreeze.Unlock()
	return mock.UnfreezeFunc(ctx, kvvmi)
}

// UnfreezeCalls gets all the calls that were made to Unfreeze.
// Check the length with:
//
//	len(mockedLifeCycleSnapshotter.UnfreezeCalls())
func (mock *LifeCycleSnapshotterMock) UnfreezeCalls() []struct {
	Ctx   context.Context
	Kvvmi *virtv1.VirtualMachineInstance
} {
	var calls []struct {
		Ctx   context.Context
		Kvvmi *virtv1.VirtualMachineInstance
	}
	mock.lockUnfreeze.RLock()
	calls = mock.calls.Unfreeze
	mock.lockUnfreeze.RUnlock()
	return calls
}
