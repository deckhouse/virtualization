// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package internal

import (
	"context"
	"github.com/deckhouse/virtualization-controller/pkg/common/mac"
	virtv2 "github.com/deckhouse/virtualization/api/core/v1alpha2"
	"sync"
)

// Ensure, that MACAddressServiceMock does implement MACAddressService.
// If this is not the case, regenerate this file with moq.
var _ MACAddressService = &MACAddressServiceMock{}

// MACAddressServiceMock is a mock implementation of MACAddressService.
//
//	func TestSomethingThatUsesMACAddressService(t *testing.T) {
//
//		// make and configure a mocked MACAddressService
//		mockedMACAddressService := &MACAddressServiceMock{
//			AllocateNewAddressFunc: func(allocatedMACs mac.AllocatedMACs) (string, error) {
//				panic("mock out the AllocateNewAddress method")
//			},
//			GetAllocatedAddressesFunc: func(ctx context.Context) (mac.AllocatedMACs, error) {
//				panic("mock out the GetAllocatedAddresses method")
//			},
//			GetLeaseFunc: func(ctx context.Context, vmmac *virtv2.VirtualMachineMACAddress) (*virtv2.VirtualMachineMACAddressLease, error) {
//				panic("mock out the GetLease method")
//			},
//		}
//
//		// use mockedMACAddressService in code that requires MACAddressService
//		// and then make assertions.
//
//	}
type MACAddressServiceMock struct {
	// AllocateNewAddressFunc mocks the AllocateNewAddress method.
	AllocateNewAddressFunc func(allocatedMACs mac.AllocatedMACs) (string, error)

	// GetAllocatedAddressesFunc mocks the GetAllocatedAddresses method.
	GetAllocatedAddressesFunc func(ctx context.Context) (mac.AllocatedMACs, error)

	// GetLeaseFunc mocks the GetLease method.
	GetLeaseFunc func(ctx context.Context, vmmac *virtv2.VirtualMachineMACAddress) (*virtv2.VirtualMachineMACAddressLease, error)

	// calls tracks calls to the methods.
	calls struct {
		// AllocateNewAddress holds details about calls to the AllocateNewAddress method.
		AllocateNewAddress []struct {
			// AllocatedMACs is the allocatedMACs argument value.
			AllocatedMACs mac.AllocatedMACs
		}
		// GetAllocatedAddresses holds details about calls to the GetAllocatedAddresses method.
		GetAllocatedAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetLease holds details about calls to the GetLease method.
		GetLease []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vmmac is the vmmac argument value.
			Vmmac *virtv2.VirtualMachineMACAddress
		}
	}
	lockAllocateNewAddress    sync.RWMutex
	lockGetAllocatedAddresses sync.RWMutex
	lockGetLease              sync.RWMutex
}

// AllocateNewAddress calls AllocateNewAddressFunc.
func (mock *MACAddressServiceMock) AllocateNewAddress(allocatedMACs mac.AllocatedMACs) (string, error) {
	if mock.AllocateNewAddressFunc == nil {
		panic("MACAddressServiceMock.AllocateNewAddressFunc: method is nil but MACAddressService.AllocateNewAddress was just called")
	}
	callInfo := struct {
		AllocatedMACs mac.AllocatedMACs
	}{
		AllocatedMACs: allocatedMACs,
	}
	mock.lockAllocateNewAddress.Lock()
	mock.calls.AllocateNewAddress = append(mock.calls.AllocateNewAddress, callInfo)
	mock.lockAllocateNewAddress.Unlock()
	return mock.AllocateNewAddressFunc(allocatedMACs)
}

// AllocateNewAddressCalls gets all the calls that were made to AllocateNewAddress.
// Check the length with:
//
//	len(mockedMACAddressService.AllocateNewAddressCalls())
func (mock *MACAddressServiceMock) AllocateNewAddressCalls() []struct {
	AllocatedMACs mac.AllocatedMACs
} {
	var calls []struct {
		AllocatedMACs mac.AllocatedMACs
	}
	mock.lockAllocateNewAddress.RLock()
	calls = mock.calls.AllocateNewAddress
	mock.lockAllocateNewAddress.RUnlock()
	return calls
}

// GetAllocatedAddresses calls GetAllocatedAddressesFunc.
func (mock *MACAddressServiceMock) GetAllocatedAddresses(ctx context.Context) (mac.AllocatedMACs, error) {
	if mock.GetAllocatedAddressesFunc == nil {
		panic("MACAddressServiceMock.GetAllocatedAddressesFunc: method is nil but MACAddressService.GetAllocatedAddresses was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllocatedAddresses.Lock()
	mock.calls.GetAllocatedAddresses = append(mock.calls.GetAllocatedAddresses, callInfo)
	mock.lockGetAllocatedAddresses.Unlock()
	return mock.GetAllocatedAddressesFunc(ctx)
}

// GetAllocatedAddressesCalls gets all the calls that were made to GetAllocatedAddresses.
// Check the length with:
//
//	len(mockedMACAddressService.GetAllocatedAddressesCalls())
func (mock *MACAddressServiceMock) GetAllocatedAddressesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllocatedAddresses.RLock()
	calls = mock.calls.GetAllocatedAddresses
	mock.lockGetAllocatedAddresses.RUnlock()
	return calls
}

// GetLease calls GetLeaseFunc.
func (mock *MACAddressServiceMock) GetLease(ctx context.Context, vmmac *virtv2.VirtualMachineMACAddress) (*virtv2.VirtualMachineMACAddressLease, error) {
	if mock.GetLeaseFunc == nil {
		panic("MACAddressServiceMock.GetLeaseFunc: method is nil but MACAddressService.GetLease was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Vmmac *virtv2.VirtualMachineMACAddress
	}{
		Ctx:   ctx,
		Vmmac: vmmac,
	}
	mock.lockGetLease.Lock()
	mock.calls.GetLease = append(mock.calls.GetLease, callInfo)
	mock.lockGetLease.Unlock()
	return mock.GetLeaseFunc(ctx, vmmac)
}

// GetLeaseCalls gets all the calls that were made to GetLease.
// Check the length with:
//
//	len(mockedMACAddressService.GetLeaseCalls())
func (mock *MACAddressServiceMock) GetLeaseCalls() []struct {
	Ctx   context.Context
	Vmmac *virtv2.VirtualMachineMACAddress
} {
	var calls []struct {
		Ctx   context.Context
		Vmmac *virtv2.VirtualMachineMACAddress
	}
	mock.lockGetLease.RLock()
	calls = mock.calls.GetLease
	mock.lockGetLease.RUnlock()
	return calls
}
