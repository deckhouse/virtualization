// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package internal

import (
	"context"
	"github.com/deckhouse/virtualization-controller/pkg/controller/vd/internal/source"
	virtv2 "github.com/deckhouse/virtualization/api/core/v1alpha2"
	"sync"
)

// Ensure, that HandlerMock does implement Handler.
// If this is not the case, regenerate this file with moq.
var _ Handler = &HandlerMock{}

// HandlerMock is a mock implementation of Handler.
//
//	func TestSomethingThatUsesHandler(t *testing.T) {
//
//		// make and configure a mocked Handler
//		mockedHandler := &HandlerMock{
//			CleanUpFunc: func(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			SyncFunc: func(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error) {
//				panic("mock out the Sync method")
//			},
//			ValidateFunc: func(ctx context.Context, vd *virtv2.VirtualDisk) error {
//				panic("mock out the Validate method")
//			},
//		}
//
//		// use mockedHandler in code that requires Handler
//		// and then make assertions.
//
//	}
type HandlerMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error)

	// SyncFunc mocks the Sync method.
	SyncFunc func(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error)

	// ValidateFunc mocks the Validate method.
	ValidateFunc func(ctx context.Context, vd *virtv2.VirtualDisk) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vd is the vd argument value.
			Vd *virtv2.VirtualDisk
		}
		// Sync holds details about calls to the Sync method.
		Sync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vd is the vd argument value.
			Vd *virtv2.VirtualDisk
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vd is the vd argument value.
			Vd *virtv2.VirtualDisk
		}
	}
	lockCleanUp  sync.RWMutex
	lockSync     sync.RWMutex
	lockValidate sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *HandlerMock) CleanUp(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("HandlerMock.CleanUpFunc: method is nil but Handler.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}{
		Ctx: ctx,
		Vd:  vd,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, vd)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedHandler.CleanUpCalls())
func (mock *HandlerMock) CleanUpCalls() []struct {
	Ctx context.Context
	Vd  *virtv2.VirtualDisk
} {
	var calls []struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// Sync calls SyncFunc.
func (mock *HandlerMock) Sync(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error) {
	if mock.SyncFunc == nil {
		panic("HandlerMock.SyncFunc: method is nil but Handler.Sync was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}{
		Ctx: ctx,
		Vd:  vd,
	}
	mock.lockSync.Lock()
	mock.calls.Sync = append(mock.calls.Sync, callInfo)
	mock.lockSync.Unlock()
	return mock.SyncFunc(ctx, vd)
}

// SyncCalls gets all the calls that were made to Sync.
// Check the length with:
//
//	len(mockedHandler.SyncCalls())
func (mock *HandlerMock) SyncCalls() []struct {
	Ctx context.Context
	Vd  *virtv2.VirtualDisk
} {
	var calls []struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}
	mock.lockSync.RLock()
	calls = mock.calls.Sync
	mock.lockSync.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *HandlerMock) Validate(ctx context.Context, vd *virtv2.VirtualDisk) error {
	if mock.ValidateFunc == nil {
		panic("HandlerMock.ValidateFunc: method is nil but Handler.Validate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}{
		Ctx: ctx,
		Vd:  vd,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	return mock.ValidateFunc(ctx, vd)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//
//	len(mockedHandler.ValidateCalls())
func (mock *HandlerMock) ValidateCalls() []struct {
	Ctx context.Context
	Vd  *virtv2.VirtualDisk
} {
	var calls []struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}

// Ensure, that SourcesMock does implement Sources.
// If this is not the case, regenerate this file with moq.
var _ Sources = &SourcesMock{}

// SourcesMock is a mock implementation of Sources.
//
//	func TestSomethingThatUsesSources(t *testing.T) {
//
//		// make and configure a mocked Sources
//		mockedSources := &SourcesMock{
//			GetFunc: func(dsType virtv2.DataSourceType) (source.Handler, bool) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedSources in code that requires Sources
//		// and then make assertions.
//
//	}
type SourcesMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(dsType virtv2.DataSourceType) (source.Handler, bool)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// DsType is the dsType argument value.
			DsType virtv2.DataSourceType
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *SourcesMock) Get(dsType virtv2.DataSourceType) (source.Handler, bool) {
	if mock.GetFunc == nil {
		panic("SourcesMock.GetFunc: method is nil but Sources.Get was just called")
	}
	callInfo := struct {
		DsType virtv2.DataSourceType
	}{
		DsType: dsType,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(dsType)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedSources.GetCalls())
func (mock *SourcesMock) GetCalls() []struct {
	DsType virtv2.DataSourceType
} {
	var calls []struct {
		DsType virtv2.DataSourceType
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}
