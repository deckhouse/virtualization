// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package source

import (
	"context"
	"github.com/deckhouse/virtualization-controller/pkg/controller/service"
	"github.com/deckhouse/virtualization-controller/pkg/controller/supplements"
	virtv2 "github.com/deckhouse/virtualization/api/core/v1alpha2"
	corev1 "k8s.io/api/core/v1"
	storagev1 "k8s.io/api/storage/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	cdiv1 "kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	"sync"
)

// Ensure, that HandlerMock does implement Handler.
// If this is not the case, regenerate this file with moq.
var _ Handler = &HandlerMock{}

// HandlerMock is a mock implementation of Handler.
//
//	func TestSomethingThatUsesHandler(t *testing.T) {
//
//		// make and configure a mocked Handler
//		mockedHandler := &HandlerMock{
//			CleanUpFunc: func(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			NameFunc: func() string {
//				panic("mock out the Name method")
//			},
//			SyncFunc: func(ctx context.Context, vd *virtv2.VirtualDisk) (reconcile.Result, error) {
//				panic("mock out the Sync method")
//			},
//			ValidateFunc: func(ctx context.Context, vd *virtv2.VirtualDisk) error {
//				panic("mock out the Validate method")
//			},
//		}
//
//		// use mockedHandler in code that requires Handler
//		// and then make assertions.
//
//	}
type HandlerMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error)

	// NameFunc mocks the Name method.
	NameFunc func() string

	// SyncFunc mocks the Sync method.
	SyncFunc func(ctx context.Context, vd *virtv2.VirtualDisk) (reconcile.Result, error)

	// ValidateFunc mocks the Validate method.
	ValidateFunc func(ctx context.Context, vd *virtv2.VirtualDisk) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vd is the vd argument value.
			Vd *virtv2.VirtualDisk
		}
		// Name holds details about calls to the Name method.
		Name []struct {
		}
		// Sync holds details about calls to the Sync method.
		Sync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vd is the vd argument value.
			Vd *virtv2.VirtualDisk
		}
		// Validate holds details about calls to the Validate method.
		Validate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Vd is the vd argument value.
			Vd *virtv2.VirtualDisk
		}
	}
	lockCleanUp  sync.RWMutex
	lockName     sync.RWMutex
	lockSync     sync.RWMutex
	lockValidate sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *HandlerMock) CleanUp(ctx context.Context, vd *virtv2.VirtualDisk) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("HandlerMock.CleanUpFunc: method is nil but Handler.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}{
		Ctx: ctx,
		Vd:  vd,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, vd)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedHandler.CleanUpCalls())
func (mock *HandlerMock) CleanUpCalls() []struct {
	Ctx context.Context
	Vd  *virtv2.VirtualDisk
} {
	var calls []struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// Name calls NameFunc.
func (mock *HandlerMock) Name() string {
	if mock.NameFunc == nil {
		panic("HandlerMock.NameFunc: method is nil but Handler.Name was just called")
	}
	callInfo := struct {
	}{}
	mock.lockName.Lock()
	mock.calls.Name = append(mock.calls.Name, callInfo)
	mock.lockName.Unlock()
	return mock.NameFunc()
}

// NameCalls gets all the calls that were made to Name.
// Check the length with:
//
//	len(mockedHandler.NameCalls())
func (mock *HandlerMock) NameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockName.RLock()
	calls = mock.calls.Name
	mock.lockName.RUnlock()
	return calls
}

// Sync calls SyncFunc.
func (mock *HandlerMock) Sync(ctx context.Context, vd *virtv2.VirtualDisk) (reconcile.Result, error) {
	if mock.SyncFunc == nil {
		panic("HandlerMock.SyncFunc: method is nil but Handler.Sync was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}{
		Ctx: ctx,
		Vd:  vd,
	}
	mock.lockSync.Lock()
	mock.calls.Sync = append(mock.calls.Sync, callInfo)
	mock.lockSync.Unlock()
	return mock.SyncFunc(ctx, vd)
}

// SyncCalls gets all the calls that were made to Sync.
// Check the length with:
//
//	len(mockedHandler.SyncCalls())
func (mock *HandlerMock) SyncCalls() []struct {
	Ctx context.Context
	Vd  *virtv2.VirtualDisk
} {
	var calls []struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}
	mock.lockSync.RLock()
	calls = mock.calls.Sync
	mock.lockSync.RUnlock()
	return calls
}

// Validate calls ValidateFunc.
func (mock *HandlerMock) Validate(ctx context.Context, vd *virtv2.VirtualDisk) error {
	if mock.ValidateFunc == nil {
		panic("HandlerMock.ValidateFunc: method is nil but Handler.Validate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}{
		Ctx: ctx,
		Vd:  vd,
	}
	mock.lockValidate.Lock()
	mock.calls.Validate = append(mock.calls.Validate, callInfo)
	mock.lockValidate.Unlock()
	return mock.ValidateFunc(ctx, vd)
}

// ValidateCalls gets all the calls that were made to Validate.
// Check the length with:
//
//	len(mockedHandler.ValidateCalls())
func (mock *HandlerMock) ValidateCalls() []struct {
	Ctx context.Context
	Vd  *virtv2.VirtualDisk
} {
	var calls []struct {
		Ctx context.Context
		Vd  *virtv2.VirtualDisk
	}
	mock.lockValidate.RLock()
	calls = mock.calls.Validate
	mock.lockValidate.RUnlock()
	return calls
}

// Ensure, that BlankDataSourceDiskServiceMock does implement BlankDataSourceDiskService.
// If this is not the case, regenerate this file with moq.
var _ BlankDataSourceDiskService = &BlankDataSourceDiskServiceMock{}

// BlankDataSourceDiskServiceMock is a mock implementation of BlankDataSourceDiskService.
//
//	func TestSomethingThatUsesBlankDataSourceDiskService(t *testing.T) {
//
//		// make and configure a mocked BlankDataSourceDiskService
//		mockedBlankDataSourceDiskService := &BlankDataSourceDiskServiceMock{
//			CleanUpFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetCapacityFunc: func(pvc *corev1.PersistentVolumeClaim) string {
//				panic("mock out the GetCapacity method")
//			},
//			GetVolumeAndAccessModesFunc: func(ctx context.Context, obj client.Object, sc *storagev1.StorageClass) (corev1.PersistentVolumeMode, corev1.PersistentVolumeAccessMode, error) {
//				panic("mock out the GetVolumeAndAccessModes method")
//			},
//			ProtectFunc: func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
//				panic("mock out the Protect method")
//			},
//		}
//
//		// use mockedBlankDataSourceDiskService in code that requires BlankDataSourceDiskService
//		// and then make assertions.
//
//	}
type BlankDataSourceDiskServiceMock struct {
	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// GetCapacityFunc mocks the GetCapacity method.
	GetCapacityFunc func(pvc *corev1.PersistentVolumeClaim) string

	// GetVolumeAndAccessModesFunc mocks the GetVolumeAndAccessModes method.
	GetVolumeAndAccessModesFunc func(ctx context.Context, obj client.Object, sc *storagev1.StorageClass) (corev1.PersistentVolumeMode, corev1.PersistentVolumeAccessMode, error)

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetCapacity holds details about calls to the GetCapacity method.
		GetCapacity []struct {
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// GetVolumeAndAccessModes holds details about calls to the GetVolumeAndAccessModes method.
		GetVolumeAndAccessModes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Obj is the obj argument value.
			Obj client.Object
			// Sc is the sc argument value.
			Sc *storagev1.StorageClass
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner client.Object
			// Dv is the dv argument value.
			Dv *cdiv1.DataVolume
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
	}
	lockCleanUp                 sync.RWMutex
	lockCleanUpSupplements      sync.RWMutex
	lockGetCapacity             sync.RWMutex
	lockGetVolumeAndAccessModes sync.RWMutex
	lockProtect                 sync.RWMutex
}

// CleanUp calls CleanUpFunc.
func (mock *BlankDataSourceDiskServiceMock) CleanUp(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("BlankDataSourceDiskServiceMock.CleanUpFunc: method is nil but BlankDataSourceDiskService.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedBlankDataSourceDiskService.CleanUpCalls())
func (mock *BlankDataSourceDiskServiceMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *BlankDataSourceDiskServiceMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("BlankDataSourceDiskServiceMock.CleanUpSupplementsFunc: method is nil but BlankDataSourceDiskService.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedBlankDataSourceDiskService.CleanUpSupplementsCalls())
func (mock *BlankDataSourceDiskServiceMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetCapacity calls GetCapacityFunc.
func (mock *BlankDataSourceDiskServiceMock) GetCapacity(pvc *corev1.PersistentVolumeClaim) string {
	if mock.GetCapacityFunc == nil {
		panic("BlankDataSourceDiskServiceMock.GetCapacityFunc: method is nil but BlankDataSourceDiskService.GetCapacity was just called")
	}
	callInfo := struct {
		Pvc *corev1.PersistentVolumeClaim
	}{
		Pvc: pvc,
	}
	mock.lockGetCapacity.Lock()
	mock.calls.GetCapacity = append(mock.calls.GetCapacity, callInfo)
	mock.lockGetCapacity.Unlock()
	return mock.GetCapacityFunc(pvc)
}

// GetCapacityCalls gets all the calls that were made to GetCapacity.
// Check the length with:
//
//	len(mockedBlankDataSourceDiskService.GetCapacityCalls())
func (mock *BlankDataSourceDiskServiceMock) GetCapacityCalls() []struct {
	Pvc *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Pvc *corev1.PersistentVolumeClaim
	}
	mock.lockGetCapacity.RLock()
	calls = mock.calls.GetCapacity
	mock.lockGetCapacity.RUnlock()
	return calls
}

// GetVolumeAndAccessModes calls GetVolumeAndAccessModesFunc.
func (mock *BlankDataSourceDiskServiceMock) GetVolumeAndAccessModes(ctx context.Context, obj client.Object, sc *storagev1.StorageClass) (corev1.PersistentVolumeMode, corev1.PersistentVolumeAccessMode, error) {
	if mock.GetVolumeAndAccessModesFunc == nil {
		panic("BlankDataSourceDiskServiceMock.GetVolumeAndAccessModesFunc: method is nil but BlankDataSourceDiskService.GetVolumeAndAccessModes was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Obj client.Object
		Sc  *storagev1.StorageClass
	}{
		Ctx: ctx,
		Obj: obj,
		Sc:  sc,
	}
	mock.lockGetVolumeAndAccessModes.Lock()
	mock.calls.GetVolumeAndAccessModes = append(mock.calls.GetVolumeAndAccessModes, callInfo)
	mock.lockGetVolumeAndAccessModes.Unlock()
	return mock.GetVolumeAndAccessModesFunc(ctx, obj, sc)
}

// GetVolumeAndAccessModesCalls gets all the calls that were made to GetVolumeAndAccessModes.
// Check the length with:
//
//	len(mockedBlankDataSourceDiskService.GetVolumeAndAccessModesCalls())
func (mock *BlankDataSourceDiskServiceMock) GetVolumeAndAccessModesCalls() []struct {
	Ctx context.Context
	Obj client.Object
	Sc  *storagev1.StorageClass
} {
	var calls []struct {
		Ctx context.Context
		Obj client.Object
		Sc  *storagev1.StorageClass
	}
	mock.lockGetVolumeAndAccessModes.RLock()
	calls = mock.calls.GetVolumeAndAccessModes
	mock.lockGetVolumeAndAccessModes.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *BlankDataSourceDiskServiceMock) Protect(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
	if mock.ProtectFunc == nil {
		panic("BlankDataSourceDiskServiceMock.ProtectFunc: method is nil but BlankDataSourceDiskService.Protect was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}{
		Ctx:   ctx,
		Owner: owner,
		Dv:    dv,
		Pvc:   pvc,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, owner, dv, pvc)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedBlankDataSourceDiskService.ProtectCalls())
func (mock *BlankDataSourceDiskServiceMock) ProtectCalls() []struct {
	Ctx   context.Context
	Owner client.Object
	Dv    *cdiv1.DataVolume
	Pvc   *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Ensure, that ObjectRefVirtualImageDiskServiceMock does implement ObjectRefVirtualImageDiskService.
// If this is not the case, regenerate this file with moq.
var _ ObjectRefVirtualImageDiskService = &ObjectRefVirtualImageDiskServiceMock{}

// ObjectRefVirtualImageDiskServiceMock is a mock implementation of ObjectRefVirtualImageDiskService.
//
//	func TestSomethingThatUsesObjectRefVirtualImageDiskService(t *testing.T) {
//
//		// make and configure a mocked ObjectRefVirtualImageDiskService
//		mockedObjectRefVirtualImageDiskService := &ObjectRefVirtualImageDiskServiceMock{
//			CheckProvisioningFunc: func(ctx context.Context, pvc *corev1.PersistentVolumeClaim) error {
//				panic("mock out the CheckProvisioning method")
//			},
//			CleanUpFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetCapacityFunc: func(pvc *corev1.PersistentVolumeClaim) string {
//				panic("mock out the GetCapacity method")
//			},
//			GetProgressFunc: func(dv *cdiv1.DataVolume, prevProgress string, opts ...service.GetProgressOption) string {
//				panic("mock out the GetProgress method")
//			},
//			ProtectFunc: func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, pvcSize resource.Quantity, sc *storagev1.StorageClass, source *cdiv1.DataVolumeSource, obj client.Object, sup supplements.DataVolumeSupplement, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//		}
//
//		// use mockedObjectRefVirtualImageDiskService in code that requires ObjectRefVirtualImageDiskService
//		// and then make assertions.
//
//	}
type ObjectRefVirtualImageDiskServiceMock struct {
	// CheckProvisioningFunc mocks the CheckProvisioning method.
	CheckProvisioningFunc func(ctx context.Context, pvc *corev1.PersistentVolumeClaim) error

	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// GetCapacityFunc mocks the GetCapacity method.
	GetCapacityFunc func(pvc *corev1.PersistentVolumeClaim) string

	// GetProgressFunc mocks the GetProgress method.
	GetProgressFunc func(dv *cdiv1.DataVolume, prevProgress string, opts ...service.GetProgressOption) string

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, pvcSize resource.Quantity, sc *storagev1.StorageClass, source *cdiv1.DataVolumeSource, obj client.Object, sup supplements.DataVolumeSupplement, opts ...service.Option) error

	// calls tracks calls to the methods.
	calls struct {
		// CheckProvisioning holds details about calls to the CheckProvisioning method.
		CheckProvisioning []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetCapacity holds details about calls to the GetCapacity method.
		GetCapacity []struct {
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// GetProgress holds details about calls to the GetProgress method.
		GetProgress []struct {
			// Dv is the dv argument value.
			Dv *cdiv1.DataVolume
			// PrevProgress is the prevProgress argument value.
			PrevProgress string
			// Opts is the opts argument value.
			Opts []service.GetProgressOption
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner client.Object
			// Dv is the dv argument value.
			Dv *cdiv1.DataVolume
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PvcSize is the pvcSize argument value.
			PvcSize resource.Quantity
			// Sc is the sc argument value.
			Sc *storagev1.StorageClass
			// Source is the source argument value.
			Source *cdiv1.DataVolumeSource
			// Obj is the obj argument value.
			Obj client.Object
			// Sup is the sup argument value.
			Sup supplements.DataVolumeSupplement
			// Opts is the opts argument value.
			Opts []service.Option
		}
	}
	lockCheckProvisioning  sync.RWMutex
	lockCleanUp            sync.RWMutex
	lockCleanUpSupplements sync.RWMutex
	lockGetCapacity        sync.RWMutex
	lockGetProgress        sync.RWMutex
	lockProtect            sync.RWMutex
	lockStart              sync.RWMutex
}

// CheckProvisioning calls CheckProvisioningFunc.
func (mock *ObjectRefVirtualImageDiskServiceMock) CheckProvisioning(ctx context.Context, pvc *corev1.PersistentVolumeClaim) error {
	if mock.CheckProvisioningFunc == nil {
		panic("ObjectRefVirtualImageDiskServiceMock.CheckProvisioningFunc: method is nil but ObjectRefVirtualImageDiskService.CheckProvisioning was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pvc *corev1.PersistentVolumeClaim
	}{
		Ctx: ctx,
		Pvc: pvc,
	}
	mock.lockCheckProvisioning.Lock()
	mock.calls.CheckProvisioning = append(mock.calls.CheckProvisioning, callInfo)
	mock.lockCheckProvisioning.Unlock()
	return mock.CheckProvisioningFunc(ctx, pvc)
}

// CheckProvisioningCalls gets all the calls that were made to CheckProvisioning.
// Check the length with:
//
//	len(mockedObjectRefVirtualImageDiskService.CheckProvisioningCalls())
func (mock *ObjectRefVirtualImageDiskServiceMock) CheckProvisioningCalls() []struct {
	Ctx context.Context
	Pvc *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Ctx context.Context
		Pvc *corev1.PersistentVolumeClaim
	}
	mock.lockCheckProvisioning.RLock()
	calls = mock.calls.CheckProvisioning
	mock.lockCheckProvisioning.RUnlock()
	return calls
}

// CleanUp calls CleanUpFunc.
func (mock *ObjectRefVirtualImageDiskServiceMock) CleanUp(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("ObjectRefVirtualImageDiskServiceMock.CleanUpFunc: method is nil but ObjectRefVirtualImageDiskService.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedObjectRefVirtualImageDiskService.CleanUpCalls())
func (mock *ObjectRefVirtualImageDiskServiceMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *ObjectRefVirtualImageDiskServiceMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("ObjectRefVirtualImageDiskServiceMock.CleanUpSupplementsFunc: method is nil but ObjectRefVirtualImageDiskService.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedObjectRefVirtualImageDiskService.CleanUpSupplementsCalls())
func (mock *ObjectRefVirtualImageDiskServiceMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetCapacity calls GetCapacityFunc.
func (mock *ObjectRefVirtualImageDiskServiceMock) GetCapacity(pvc *corev1.PersistentVolumeClaim) string {
	if mock.GetCapacityFunc == nil {
		panic("ObjectRefVirtualImageDiskServiceMock.GetCapacityFunc: method is nil but ObjectRefVirtualImageDiskService.GetCapacity was just called")
	}
	callInfo := struct {
		Pvc *corev1.PersistentVolumeClaim
	}{
		Pvc: pvc,
	}
	mock.lockGetCapacity.Lock()
	mock.calls.GetCapacity = append(mock.calls.GetCapacity, callInfo)
	mock.lockGetCapacity.Unlock()
	return mock.GetCapacityFunc(pvc)
}

// GetCapacityCalls gets all the calls that were made to GetCapacity.
// Check the length with:
//
//	len(mockedObjectRefVirtualImageDiskService.GetCapacityCalls())
func (mock *ObjectRefVirtualImageDiskServiceMock) GetCapacityCalls() []struct {
	Pvc *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Pvc *corev1.PersistentVolumeClaim
	}
	mock.lockGetCapacity.RLock()
	calls = mock.calls.GetCapacity
	mock.lockGetCapacity.RUnlock()
	return calls
}

// GetProgress calls GetProgressFunc.
func (mock *ObjectRefVirtualImageDiskServiceMock) GetProgress(dv *cdiv1.DataVolume, prevProgress string, opts ...service.GetProgressOption) string {
	if mock.GetProgressFunc == nil {
		panic("ObjectRefVirtualImageDiskServiceMock.GetProgressFunc: method is nil but ObjectRefVirtualImageDiskService.GetProgress was just called")
	}
	callInfo := struct {
		Dv           *cdiv1.DataVolume
		PrevProgress string
		Opts         []service.GetProgressOption
	}{
		Dv:           dv,
		PrevProgress: prevProgress,
		Opts:         opts,
	}
	mock.lockGetProgress.Lock()
	mock.calls.GetProgress = append(mock.calls.GetProgress, callInfo)
	mock.lockGetProgress.Unlock()
	return mock.GetProgressFunc(dv, prevProgress, opts...)
}

// GetProgressCalls gets all the calls that were made to GetProgress.
// Check the length with:
//
//	len(mockedObjectRefVirtualImageDiskService.GetProgressCalls())
func (mock *ObjectRefVirtualImageDiskServiceMock) GetProgressCalls() []struct {
	Dv           *cdiv1.DataVolume
	PrevProgress string
	Opts         []service.GetProgressOption
} {
	var calls []struct {
		Dv           *cdiv1.DataVolume
		PrevProgress string
		Opts         []service.GetProgressOption
	}
	mock.lockGetProgress.RLock()
	calls = mock.calls.GetProgress
	mock.lockGetProgress.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *ObjectRefVirtualImageDiskServiceMock) Protect(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
	if mock.ProtectFunc == nil {
		panic("ObjectRefVirtualImageDiskServiceMock.ProtectFunc: method is nil but ObjectRefVirtualImageDiskService.Protect was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}{
		Ctx:   ctx,
		Owner: owner,
		Dv:    dv,
		Pvc:   pvc,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, owner, dv, pvc)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedObjectRefVirtualImageDiskService.ProtectCalls())
func (mock *ObjectRefVirtualImageDiskServiceMock) ProtectCalls() []struct {
	Ctx   context.Context
	Owner client.Object
	Dv    *cdiv1.DataVolume
	Pvc   *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *ObjectRefVirtualImageDiskServiceMock) Start(ctx context.Context, pvcSize resource.Quantity, sc *storagev1.StorageClass, source *cdiv1.DataVolumeSource, obj client.Object, sup supplements.DataVolumeSupplement, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("ObjectRefVirtualImageDiskServiceMock.StartFunc: method is nil but ObjectRefVirtualImageDiskService.Start was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		PvcSize resource.Quantity
		Sc      *storagev1.StorageClass
		Source  *cdiv1.DataVolumeSource
		Obj     client.Object
		Sup     supplements.DataVolumeSupplement
		Opts    []service.Option
	}{
		Ctx:     ctx,
		PvcSize: pvcSize,
		Sc:      sc,
		Source:  source,
		Obj:     obj,
		Sup:     sup,
		Opts:    opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, pvcSize, sc, source, obj, sup, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedObjectRefVirtualImageDiskService.StartCalls())
func (mock *ObjectRefVirtualImageDiskServiceMock) StartCalls() []struct {
	Ctx     context.Context
	PvcSize resource.Quantity
	Sc      *storagev1.StorageClass
	Source  *cdiv1.DataVolumeSource
	Obj     client.Object
	Sup     supplements.DataVolumeSupplement
	Opts    []service.Option
} {
	var calls []struct {
		Ctx     context.Context
		PvcSize resource.Quantity
		Sc      *storagev1.StorageClass
		Source  *cdiv1.DataVolumeSource
		Obj     client.Object
		Sup     supplements.DataVolumeSupplement
		Opts    []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Ensure, that ObjectRefClusterVirtualImageDiskServiceMock does implement ObjectRefClusterVirtualImageDiskService.
// If this is not the case, regenerate this file with moq.
var _ ObjectRefClusterVirtualImageDiskService = &ObjectRefClusterVirtualImageDiskServiceMock{}

// ObjectRefClusterVirtualImageDiskServiceMock is a mock implementation of ObjectRefClusterVirtualImageDiskService.
//
//	func TestSomethingThatUsesObjectRefClusterVirtualImageDiskService(t *testing.T) {
//
//		// make and configure a mocked ObjectRefClusterVirtualImageDiskService
//		mockedObjectRefClusterVirtualImageDiskService := &ObjectRefClusterVirtualImageDiskServiceMock{
//			CheckProvisioningFunc: func(ctx context.Context, pvc *corev1.PersistentVolumeClaim) error {
//				panic("mock out the CheckProvisioning method")
//			},
//			CleanUpFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUp method")
//			},
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetCapacityFunc: func(pvc *corev1.PersistentVolumeClaim) string {
//				panic("mock out the GetCapacity method")
//			},
//			GetProgressFunc: func(dv *cdiv1.DataVolume, prevProgress string, opts ...service.GetProgressOption) string {
//				panic("mock out the GetProgress method")
//			},
//			ProtectFunc: func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
//				panic("mock out the Protect method")
//			},
//			StartFunc: func(ctx context.Context, pvcSize resource.Quantity, sc *storagev1.StorageClass, source *cdiv1.DataVolumeSource, obj client.Object, sup supplements.DataVolumeSupplement, opts ...service.Option) error {
//				panic("mock out the Start method")
//			},
//		}
//
//		// use mockedObjectRefClusterVirtualImageDiskService in code that requires ObjectRefClusterVirtualImageDiskService
//		// and then make assertions.
//
//	}
type ObjectRefClusterVirtualImageDiskServiceMock struct {
	// CheckProvisioningFunc mocks the CheckProvisioning method.
	CheckProvisioningFunc func(ctx context.Context, pvc *corev1.PersistentVolumeClaim) error

	// CleanUpFunc mocks the CleanUp method.
	CleanUpFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// GetCapacityFunc mocks the GetCapacity method.
	GetCapacityFunc func(pvc *corev1.PersistentVolumeClaim) string

	// GetProgressFunc mocks the GetProgress method.
	GetProgressFunc func(dv *cdiv1.DataVolume, prevProgress string, opts ...service.GetProgressOption) string

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, pvcSize resource.Quantity, sc *storagev1.StorageClass, source *cdiv1.DataVolumeSource, obj client.Object, sup supplements.DataVolumeSupplement, opts ...service.Option) error

	// calls tracks calls to the methods.
	calls struct {
		// CheckProvisioning holds details about calls to the CheckProvisioning method.
		CheckProvisioning []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// CleanUp holds details about calls to the CleanUp method.
		CleanUp []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetCapacity holds details about calls to the GetCapacity method.
		GetCapacity []struct {
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// GetProgress holds details about calls to the GetProgress method.
		GetProgress []struct {
			// Dv is the dv argument value.
			Dv *cdiv1.DataVolume
			// PrevProgress is the prevProgress argument value.
			PrevProgress string
			// Opts is the opts argument value.
			Opts []service.GetProgressOption
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner client.Object
			// Dv is the dv argument value.
			Dv *cdiv1.DataVolume
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PvcSize is the pvcSize argument value.
			PvcSize resource.Quantity
			// Sc is the sc argument value.
			Sc *storagev1.StorageClass
			// Source is the source argument value.
			Source *cdiv1.DataVolumeSource
			// Obj is the obj argument value.
			Obj client.Object
			// Sup is the sup argument value.
			Sup supplements.DataVolumeSupplement
			// Opts is the opts argument value.
			Opts []service.Option
		}
	}
	lockCheckProvisioning  sync.RWMutex
	lockCleanUp            sync.RWMutex
	lockCleanUpSupplements sync.RWMutex
	lockGetCapacity        sync.RWMutex
	lockGetProgress        sync.RWMutex
	lockProtect            sync.RWMutex
	lockStart              sync.RWMutex
}

// CheckProvisioning calls CheckProvisioningFunc.
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) CheckProvisioning(ctx context.Context, pvc *corev1.PersistentVolumeClaim) error {
	if mock.CheckProvisioningFunc == nil {
		panic("ObjectRefClusterVirtualImageDiskServiceMock.CheckProvisioningFunc: method is nil but ObjectRefClusterVirtualImageDiskService.CheckProvisioning was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pvc *corev1.PersistentVolumeClaim
	}{
		Ctx: ctx,
		Pvc: pvc,
	}
	mock.lockCheckProvisioning.Lock()
	mock.calls.CheckProvisioning = append(mock.calls.CheckProvisioning, callInfo)
	mock.lockCheckProvisioning.Unlock()
	return mock.CheckProvisioningFunc(ctx, pvc)
}

// CheckProvisioningCalls gets all the calls that were made to CheckProvisioning.
// Check the length with:
//
//	len(mockedObjectRefClusterVirtualImageDiskService.CheckProvisioningCalls())
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) CheckProvisioningCalls() []struct {
	Ctx context.Context
	Pvc *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Ctx context.Context
		Pvc *corev1.PersistentVolumeClaim
	}
	mock.lockCheckProvisioning.RLock()
	calls = mock.calls.CheckProvisioning
	mock.lockCheckProvisioning.RUnlock()
	return calls
}

// CleanUp calls CleanUpFunc.
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) CleanUp(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpFunc == nil {
		panic("ObjectRefClusterVirtualImageDiskServiceMock.CleanUpFunc: method is nil but ObjectRefClusterVirtualImageDiskService.CleanUp was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUp.Lock()
	mock.calls.CleanUp = append(mock.calls.CleanUp, callInfo)
	mock.lockCleanUp.Unlock()
	return mock.CleanUpFunc(ctx, sup)
}

// CleanUpCalls gets all the calls that were made to CleanUp.
// Check the length with:
//
//	len(mockedObjectRefClusterVirtualImageDiskService.CleanUpCalls())
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) CleanUpCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUp.RLock()
	calls = mock.calls.CleanUp
	mock.lockCleanUp.RUnlock()
	return calls
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("ObjectRefClusterVirtualImageDiskServiceMock.CleanUpSupplementsFunc: method is nil but ObjectRefClusterVirtualImageDiskService.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedObjectRefClusterVirtualImageDiskService.CleanUpSupplementsCalls())
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetCapacity calls GetCapacityFunc.
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) GetCapacity(pvc *corev1.PersistentVolumeClaim) string {
	if mock.GetCapacityFunc == nil {
		panic("ObjectRefClusterVirtualImageDiskServiceMock.GetCapacityFunc: method is nil but ObjectRefClusterVirtualImageDiskService.GetCapacity was just called")
	}
	callInfo := struct {
		Pvc *corev1.PersistentVolumeClaim
	}{
		Pvc: pvc,
	}
	mock.lockGetCapacity.Lock()
	mock.calls.GetCapacity = append(mock.calls.GetCapacity, callInfo)
	mock.lockGetCapacity.Unlock()
	return mock.GetCapacityFunc(pvc)
}

// GetCapacityCalls gets all the calls that were made to GetCapacity.
// Check the length with:
//
//	len(mockedObjectRefClusterVirtualImageDiskService.GetCapacityCalls())
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) GetCapacityCalls() []struct {
	Pvc *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Pvc *corev1.PersistentVolumeClaim
	}
	mock.lockGetCapacity.RLock()
	calls = mock.calls.GetCapacity
	mock.lockGetCapacity.RUnlock()
	return calls
}

// GetProgress calls GetProgressFunc.
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) GetProgress(dv *cdiv1.DataVolume, prevProgress string, opts ...service.GetProgressOption) string {
	if mock.GetProgressFunc == nil {
		panic("ObjectRefClusterVirtualImageDiskServiceMock.GetProgressFunc: method is nil but ObjectRefClusterVirtualImageDiskService.GetProgress was just called")
	}
	callInfo := struct {
		Dv           *cdiv1.DataVolume
		PrevProgress string
		Opts         []service.GetProgressOption
	}{
		Dv:           dv,
		PrevProgress: prevProgress,
		Opts:         opts,
	}
	mock.lockGetProgress.Lock()
	mock.calls.GetProgress = append(mock.calls.GetProgress, callInfo)
	mock.lockGetProgress.Unlock()
	return mock.GetProgressFunc(dv, prevProgress, opts...)
}

// GetProgressCalls gets all the calls that were made to GetProgress.
// Check the length with:
//
//	len(mockedObjectRefClusterVirtualImageDiskService.GetProgressCalls())
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) GetProgressCalls() []struct {
	Dv           *cdiv1.DataVolume
	PrevProgress string
	Opts         []service.GetProgressOption
} {
	var calls []struct {
		Dv           *cdiv1.DataVolume
		PrevProgress string
		Opts         []service.GetProgressOption
	}
	mock.lockGetProgress.RLock()
	calls = mock.calls.GetProgress
	mock.lockGetProgress.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) Protect(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
	if mock.ProtectFunc == nil {
		panic("ObjectRefClusterVirtualImageDiskServiceMock.ProtectFunc: method is nil but ObjectRefClusterVirtualImageDiskService.Protect was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}{
		Ctx:   ctx,
		Owner: owner,
		Dv:    dv,
		Pvc:   pvc,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, owner, dv, pvc)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedObjectRefClusterVirtualImageDiskService.ProtectCalls())
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) ProtectCalls() []struct {
	Ctx   context.Context
	Owner client.Object
	Dv    *cdiv1.DataVolume
	Pvc   *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) Start(ctx context.Context, pvcSize resource.Quantity, sc *storagev1.StorageClass, source *cdiv1.DataVolumeSource, obj client.Object, sup supplements.DataVolumeSupplement, opts ...service.Option) error {
	if mock.StartFunc == nil {
		panic("ObjectRefClusterVirtualImageDiskServiceMock.StartFunc: method is nil but ObjectRefClusterVirtualImageDiskService.Start was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		PvcSize resource.Quantity
		Sc      *storagev1.StorageClass
		Source  *cdiv1.DataVolumeSource
		Obj     client.Object
		Sup     supplements.DataVolumeSupplement
		Opts    []service.Option
	}{
		Ctx:     ctx,
		PvcSize: pvcSize,
		Sc:      sc,
		Source:  source,
		Obj:     obj,
		Sup:     sup,
		Opts:    opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, pvcSize, sc, source, obj, sup, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedObjectRefClusterVirtualImageDiskService.StartCalls())
func (mock *ObjectRefClusterVirtualImageDiskServiceMock) StartCalls() []struct {
	Ctx     context.Context
	PvcSize resource.Quantity
	Sc      *storagev1.StorageClass
	Source  *cdiv1.DataVolumeSource
	Obj     client.Object
	Sup     supplements.DataVolumeSupplement
	Opts    []service.Option
} {
	var calls []struct {
		Ctx     context.Context
		PvcSize resource.Quantity
		Sc      *storagev1.StorageClass
		Source  *cdiv1.DataVolumeSource
		Obj     client.Object
		Sup     supplements.DataVolumeSupplement
		Opts    []service.Option
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Ensure, that ObjectRefVirtualDiskSnapshotDiskServiceMock does implement ObjectRefVirtualDiskSnapshotDiskService.
// If this is not the case, regenerate this file with moq.
var _ ObjectRefVirtualDiskSnapshotDiskService = &ObjectRefVirtualDiskSnapshotDiskServiceMock{}

// ObjectRefVirtualDiskSnapshotDiskServiceMock is a mock implementation of ObjectRefVirtualDiskSnapshotDiskService.
//
//	func TestSomethingThatUsesObjectRefVirtualDiskSnapshotDiskService(t *testing.T) {
//
//		// make and configure a mocked ObjectRefVirtualDiskSnapshotDiskService
//		mockedObjectRefVirtualDiskSnapshotDiskService := &ObjectRefVirtualDiskSnapshotDiskServiceMock{
//			CleanUpSupplementsFunc: func(ctx context.Context, sup supplements.Generator) (bool, error) {
//				panic("mock out the CleanUpSupplements method")
//			},
//			GetCapacityFunc: func(pvc *corev1.PersistentVolumeClaim) string {
//				panic("mock out the GetCapacity method")
//			},
//			ProtectFunc: func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
//				panic("mock out the Protect method")
//			},
//		}
//
//		// use mockedObjectRefVirtualDiskSnapshotDiskService in code that requires ObjectRefVirtualDiskSnapshotDiskService
//		// and then make assertions.
//
//	}
type ObjectRefVirtualDiskSnapshotDiskServiceMock struct {
	// CleanUpSupplementsFunc mocks the CleanUpSupplements method.
	CleanUpSupplementsFunc func(ctx context.Context, sup supplements.Generator) (bool, error)

	// GetCapacityFunc mocks the GetCapacity method.
	GetCapacityFunc func(pvc *corev1.PersistentVolumeClaim) string

	// ProtectFunc mocks the Protect method.
	ProtectFunc func(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error

	// calls tracks calls to the methods.
	calls struct {
		// CleanUpSupplements holds details about calls to the CleanUpSupplements method.
		CleanUpSupplements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sup is the sup argument value.
			Sup supplements.Generator
		}
		// GetCapacity holds details about calls to the GetCapacity method.
		GetCapacity []struct {
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
		// Protect holds details about calls to the Protect method.
		Protect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Owner is the owner argument value.
			Owner client.Object
			// Dv is the dv argument value.
			Dv *cdiv1.DataVolume
			// Pvc is the pvc argument value.
			Pvc *corev1.PersistentVolumeClaim
		}
	}
	lockCleanUpSupplements sync.RWMutex
	lockGetCapacity        sync.RWMutex
	lockProtect            sync.RWMutex
}

// CleanUpSupplements calls CleanUpSupplementsFunc.
func (mock *ObjectRefVirtualDiskSnapshotDiskServiceMock) CleanUpSupplements(ctx context.Context, sup supplements.Generator) (bool, error) {
	if mock.CleanUpSupplementsFunc == nil {
		panic("ObjectRefVirtualDiskSnapshotDiskServiceMock.CleanUpSupplementsFunc: method is nil but ObjectRefVirtualDiskSnapshotDiskService.CleanUpSupplements was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Sup supplements.Generator
	}{
		Ctx: ctx,
		Sup: sup,
	}
	mock.lockCleanUpSupplements.Lock()
	mock.calls.CleanUpSupplements = append(mock.calls.CleanUpSupplements, callInfo)
	mock.lockCleanUpSupplements.Unlock()
	return mock.CleanUpSupplementsFunc(ctx, sup)
}

// CleanUpSupplementsCalls gets all the calls that were made to CleanUpSupplements.
// Check the length with:
//
//	len(mockedObjectRefVirtualDiskSnapshotDiskService.CleanUpSupplementsCalls())
func (mock *ObjectRefVirtualDiskSnapshotDiskServiceMock) CleanUpSupplementsCalls() []struct {
	Ctx context.Context
	Sup supplements.Generator
} {
	var calls []struct {
		Ctx context.Context
		Sup supplements.Generator
	}
	mock.lockCleanUpSupplements.RLock()
	calls = mock.calls.CleanUpSupplements
	mock.lockCleanUpSupplements.RUnlock()
	return calls
}

// GetCapacity calls GetCapacityFunc.
func (mock *ObjectRefVirtualDiskSnapshotDiskServiceMock) GetCapacity(pvc *corev1.PersistentVolumeClaim) string {
	if mock.GetCapacityFunc == nil {
		panic("ObjectRefVirtualDiskSnapshotDiskServiceMock.GetCapacityFunc: method is nil but ObjectRefVirtualDiskSnapshotDiskService.GetCapacity was just called")
	}
	callInfo := struct {
		Pvc *corev1.PersistentVolumeClaim
	}{
		Pvc: pvc,
	}
	mock.lockGetCapacity.Lock()
	mock.calls.GetCapacity = append(mock.calls.GetCapacity, callInfo)
	mock.lockGetCapacity.Unlock()
	return mock.GetCapacityFunc(pvc)
}

// GetCapacityCalls gets all the calls that were made to GetCapacity.
// Check the length with:
//
//	len(mockedObjectRefVirtualDiskSnapshotDiskService.GetCapacityCalls())
func (mock *ObjectRefVirtualDiskSnapshotDiskServiceMock) GetCapacityCalls() []struct {
	Pvc *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Pvc *corev1.PersistentVolumeClaim
	}
	mock.lockGetCapacity.RLock()
	calls = mock.calls.GetCapacity
	mock.lockGetCapacity.RUnlock()
	return calls
}

// Protect calls ProtectFunc.
func (mock *ObjectRefVirtualDiskSnapshotDiskServiceMock) Protect(ctx context.Context, owner client.Object, dv *cdiv1.DataVolume, pvc *corev1.PersistentVolumeClaim) error {
	if mock.ProtectFunc == nil {
		panic("ObjectRefVirtualDiskSnapshotDiskServiceMock.ProtectFunc: method is nil but ObjectRefVirtualDiskSnapshotDiskService.Protect was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}{
		Ctx:   ctx,
		Owner: owner,
		Dv:    dv,
		Pvc:   pvc,
	}
	mock.lockProtect.Lock()
	mock.calls.Protect = append(mock.calls.Protect, callInfo)
	mock.lockProtect.Unlock()
	return mock.ProtectFunc(ctx, owner, dv, pvc)
}

// ProtectCalls gets all the calls that were made to Protect.
// Check the length with:
//
//	len(mockedObjectRefVirtualDiskSnapshotDiskService.ProtectCalls())
func (mock *ObjectRefVirtualDiskSnapshotDiskServiceMock) ProtectCalls() []struct {
	Ctx   context.Context
	Owner client.Object
	Dv    *cdiv1.DataVolume
	Pvc   *corev1.PersistentVolumeClaim
} {
	var calls []struct {
		Ctx   context.Context
		Owner client.Object
		Dv    *cdiv1.DataVolume
		Pvc   *corev1.PersistentVolumeClaim
	}
	mock.lockProtect.RLock()
	calls = mock.calls.Protect
	mock.lockProtect.RUnlock()
	return calls
}
