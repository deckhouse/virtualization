// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package eventrecord

import (
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sync"
)

// Ensure, that EventRecorderLoggerMock does implement EventRecorderLogger.
// If this is not the case, regenerate this file with moq.
var _ EventRecorderLogger = &EventRecorderLoggerMock{}

// EventRecorderLoggerMock is a mock implementation of EventRecorderLogger.
//
//	func TestSomethingThatUsesEventRecorderLogger(t *testing.T) {
//
//		// make and configure a mocked EventRecorderLogger
//		mockedEventRecorderLogger := &EventRecorderLoggerMock{
//			AnnotatedEventfFunc: func(involved client.Object, annotations map[string]string, eventtype string, reason string, messageFmt string, args ...interface{})  {
//				panic("mock out the AnnotatedEventf method")
//			},
//			EventFunc: func(object client.Object, eventtype string, reason string, message string)  {
//				panic("mock out the Event method")
//			},
//			EventfFunc: func(involved client.Object, eventtype string, reason string, messageFmt string, args ...interface{})  {
//				panic("mock out the Eventf method")
//			},
//			WithLoggingFunc: func(logger InfoLogger) EventRecorderLogger {
//				panic("mock out the WithLogging method")
//			},
//		}
//
//		// use mockedEventRecorderLogger in code that requires EventRecorderLogger
//		// and then make assertions.
//
//	}
type EventRecorderLoggerMock struct {
	// AnnotatedEventfFunc mocks the AnnotatedEventf method.
	AnnotatedEventfFunc func(involved client.Object, annotations map[string]string, eventtype string, reason string, messageFmt string, args ...interface{})

	// EventFunc mocks the Event method.
	EventFunc func(object client.Object, eventtype string, reason string, message string)

	// EventfFunc mocks the Eventf method.
	EventfFunc func(involved client.Object, eventtype string, reason string, messageFmt string, args ...interface{})

	// WithLoggingFunc mocks the WithLogging method.
	WithLoggingFunc func(logger InfoLogger) EventRecorderLogger

	// calls tracks calls to the methods.
	calls struct {
		// AnnotatedEventf holds details about calls to the AnnotatedEventf method.
		AnnotatedEventf []struct {
			// Involved is the involved argument value.
			Involved client.Object
			// Annotations is the annotations argument value.
			Annotations map[string]string
			// Eventtype is the eventtype argument value.
			Eventtype string
			// Reason is the reason argument value.
			Reason string
			// MessageFmt is the messageFmt argument value.
			MessageFmt string
			// Args is the args argument value.
			Args []interface{}
		}
		// Event holds details about calls to the Event method.
		Event []struct {
			// Object is the object argument value.
			Object client.Object
			// Eventtype is the eventtype argument value.
			Eventtype string
			// Reason is the reason argument value.
			Reason string
			// Message is the message argument value.
			Message string
		}
		// Eventf holds details about calls to the Eventf method.
		Eventf []struct {
			// Involved is the involved argument value.
			Involved client.Object
			// Eventtype is the eventtype argument value.
			Eventtype string
			// Reason is the reason argument value.
			Reason string
			// MessageFmt is the messageFmt argument value.
			MessageFmt string
			// Args is the args argument value.
			Args []interface{}
		}
		// WithLogging holds details about calls to the WithLogging method.
		WithLogging []struct {
			// Logger is the logger argument value.
			Logger InfoLogger
		}
	}
	lockAnnotatedEventf sync.RWMutex
	lockEvent           sync.RWMutex
	lockEventf          sync.RWMutex
	lockWithLogging     sync.RWMutex
}

// AnnotatedEventf calls AnnotatedEventfFunc.
func (mock *EventRecorderLoggerMock) AnnotatedEventf(involved client.Object, annotations map[string]string, eventtype string, reason string, messageFmt string, args ...interface{}) {
	if mock.AnnotatedEventfFunc == nil {
		panic("EventRecorderLoggerMock.AnnotatedEventfFunc: method is nil but EventRecorderLogger.AnnotatedEventf was just called")
	}
	callInfo := struct {
		Involved    client.Object
		Annotations map[string]string
		Eventtype   string
		Reason      string
		MessageFmt  string
		Args        []interface{}
	}{
		Involved:    involved,
		Annotations: annotations,
		Eventtype:   eventtype,
		Reason:      reason,
		MessageFmt:  messageFmt,
		Args:        args,
	}
	mock.lockAnnotatedEventf.Lock()
	mock.calls.AnnotatedEventf = append(mock.calls.AnnotatedEventf, callInfo)
	mock.lockAnnotatedEventf.Unlock()
	mock.AnnotatedEventfFunc(involved, annotations, eventtype, reason, messageFmt, args...)
}

// AnnotatedEventfCalls gets all the calls that were made to AnnotatedEventf.
// Check the length with:
//
//	len(mockedEventRecorderLogger.AnnotatedEventfCalls())
func (mock *EventRecorderLoggerMock) AnnotatedEventfCalls() []struct {
	Involved    client.Object
	Annotations map[string]string
	Eventtype   string
	Reason      string
	MessageFmt  string
	Args        []interface{}
} {
	var calls []struct {
		Involved    client.Object
		Annotations map[string]string
		Eventtype   string
		Reason      string
		MessageFmt  string
		Args        []interface{}
	}
	mock.lockAnnotatedEventf.RLock()
	calls = mock.calls.AnnotatedEventf
	mock.lockAnnotatedEventf.RUnlock()
	return calls
}

// Event calls EventFunc.
func (mock *EventRecorderLoggerMock) Event(object client.Object, eventtype string, reason string, message string) {
	if mock.EventFunc == nil {
		panic("EventRecorderLoggerMock.EventFunc: method is nil but EventRecorderLogger.Event was just called")
	}
	callInfo := struct {
		Object    client.Object
		Eventtype string
		Reason    string
		Message   string
	}{
		Object:    object,
		Eventtype: eventtype,
		Reason:    reason,
		Message:   message,
	}
	mock.lockEvent.Lock()
	mock.calls.Event = append(mock.calls.Event, callInfo)
	mock.lockEvent.Unlock()
	mock.EventFunc(object, eventtype, reason, message)
}

// EventCalls gets all the calls that were made to Event.
// Check the length with:
//
//	len(mockedEventRecorderLogger.EventCalls())
func (mock *EventRecorderLoggerMock) EventCalls() []struct {
	Object    client.Object
	Eventtype string
	Reason    string
	Message   string
} {
	var calls []struct {
		Object    client.Object
		Eventtype string
		Reason    string
		Message   string
	}
	mock.lockEvent.RLock()
	calls = mock.calls.Event
	mock.lockEvent.RUnlock()
	return calls
}

// Eventf calls EventfFunc.
func (mock *EventRecorderLoggerMock) Eventf(involved client.Object, eventtype string, reason string, messageFmt string, args ...interface{}) {
	if mock.EventfFunc == nil {
		panic("EventRecorderLoggerMock.EventfFunc: method is nil but EventRecorderLogger.Eventf was just called")
	}
	callInfo := struct {
		Involved   client.Object
		Eventtype  string
		Reason     string
		MessageFmt string
		Args       []interface{}
	}{
		Involved:   involved,
		Eventtype:  eventtype,
		Reason:     reason,
		MessageFmt: messageFmt,
		Args:       args,
	}
	mock.lockEventf.Lock()
	mock.calls.Eventf = append(mock.calls.Eventf, callInfo)
	mock.lockEventf.Unlock()
	mock.EventfFunc(involved, eventtype, reason, messageFmt, args...)
}

// EventfCalls gets all the calls that were made to Eventf.
// Check the length with:
//
//	len(mockedEventRecorderLogger.EventfCalls())
func (mock *EventRecorderLoggerMock) EventfCalls() []struct {
	Involved   client.Object
	Eventtype  string
	Reason     string
	MessageFmt string
	Args       []interface{}
} {
	var calls []struct {
		Involved   client.Object
		Eventtype  string
		Reason     string
		MessageFmt string
		Args       []interface{}
	}
	mock.lockEventf.RLock()
	calls = mock.calls.Eventf
	mock.lockEventf.RUnlock()
	return calls
}

// WithLogging calls WithLoggingFunc.
func (mock *EventRecorderLoggerMock) WithLogging(logger InfoLogger) EventRecorderLogger {
	if mock.WithLoggingFunc == nil {
		panic("EventRecorderLoggerMock.WithLoggingFunc: method is nil but EventRecorderLogger.WithLogging was just called")
	}
	callInfo := struct {
		Logger InfoLogger
	}{
		Logger: logger,
	}
	mock.lockWithLogging.Lock()
	mock.calls.WithLogging = append(mock.calls.WithLogging, callInfo)
	mock.lockWithLogging.Unlock()
	return mock.WithLoggingFunc(logger)
}

// WithLoggingCalls gets all the calls that were made to WithLogging.
// Check the length with:
//
//	len(mockedEventRecorderLogger.WithLoggingCalls())
func (mock *EventRecorderLoggerMock) WithLoggingCalls() []struct {
	Logger InfoLogger
} {
	var calls []struct {
		Logger InfoLogger
	}
	mock.lockWithLogging.RLock()
	calls = mock.calls.WithLogging
	mock.lockWithLogging.RUnlock()
	return calls
}
