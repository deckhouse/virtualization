diff --git a/pkg/host-disk/host-disk.go b/pkg/host-disk/host-disk.go
index 7ada596d87..f9d6aed9bb 100644
--- a/pkg/host-disk/host-disk.go
+++ b/pkg/host-disk/host-disk.go
@@ -22,6 +22,7 @@ package hostdisk
 import (
 	"fmt"
 	"os"
+	"os/exec"
 	"path"
 	"path/filepath"
 	"syscall"
@@ -171,6 +172,14 @@ func createSparseRaw(fullPath string, size int64) (err error) {
 	return nil
 }
 
+func createQcow2(fullPath string, size int64) (err error) {
+	cmd := exec.Command("qemu-img", "create", "-f", "qcow2", fullPath, fmt.Sprintf("%db", size))
+	if err = cmd.Run(); err != nil {
+		return fmt.Errorf("failed to create qcow2: %w", err)
+	}
+	return nil
+}
+
 func getPVCDiskImgPath(volumeName string, diskName string) string {
 	return path.Join(pvcBaseDir, volumeName, diskName)
 }
@@ -261,7 +270,7 @@ func (hdc *DiskImgCreator) handleRequestedSizeAndCreateSparseRaw(vmi *v1.Virtual
 			return err
 		}
 	}
-	err = createSparseRaw(diskPath, requestedSize)
+	err = createQcow2(diskPath, requestedSize)
 	if err != nil {
 		log.Log.Reason(err).Errorf("Couldn't create a sparse raw file for disk path: %s, error: %v", diskPath, err)
 		return err
diff --git a/pkg/virt-launcher/virtwrap/converter/converter.go b/pkg/virt-launcher/virtwrap/converter/converter.go
index c64b315d8f..71bbe50037 100644
--- a/pkg/virt-launcher/virtwrap/converter/converter.go
+++ b/pkg/virt-launcher/virtwrap/converter/converter.go
@@ -590,7 +590,6 @@ func Add_Agent_To_api_Channel() (channel api.Channel) {
 }
 
 func Convert_v1_Volume_To_api_Disk(source *v1.Volume, disk *api.Disk, c *ConverterContext, diskIndex int) error {
-
 	if source.ContainerDisk != nil {
 		return Convert_v1_ContainerDiskSource_To_api_Disk(source.Name, source.ContainerDisk, disk, c, diskIndex)
 	}
@@ -733,7 +732,7 @@ func Convert_v1_Hotplug_DataVolume_To_api_Disk(name string, disk *api.Disk, c *C
 // Convert_v1_FilesystemVolumeSource_To_api_Disk takes a FS source and builds the domain Disk representation
 func Convert_v1_FilesystemVolumeSource_To_api_Disk(volumeName string, disk *api.Disk, volumesDiscardIgnore []string) error {
 	disk.Type = "file"
-	disk.Driver.Type = "raw"
+	disk.Driver.Type = "qcow2"
 	disk.Driver.ErrorPolicy = "stop"
 	disk.Source.File = GetFilesystemVolumePath(volumeName)
 	if !contains(volumesDiscardIgnore, volumeName) {
@@ -745,7 +744,7 @@ func Convert_v1_FilesystemVolumeSource_To_api_Disk(volumeName string, disk *api.
 // Convert_v1_Hotplug_FilesystemVolumeSource_To_api_Disk takes a FS source and builds the KVM Disk representation
 func Convert_v1_Hotplug_FilesystemVolumeSource_To_api_Disk(volumeName string, disk *api.Disk, volumesDiscardIgnore []string) error {
 	disk.Type = "file"
-	disk.Driver.Type = "raw"
+	disk.Driver.Type = "qcow2"
 	disk.Driver.ErrorPolicy = "stop"
 	if !contains(volumesDiscardIgnore, volumeName) {
 		disk.Driver.Discard = "unmap"
@@ -779,13 +778,37 @@ func Convert_v1_Hotplug_BlockVolumeSource_To_api_Disk(volumeName string, disk *a
 }
 
 func Convert_v1_HostDisk_To_api_Disk(volumeName string, path string, disk *api.Disk) error {
+	file := hostdisk.GetMountedHostDiskPath(volumeName, path)
+	format, err := getFormat(file)
+	if err != nil {
+		return fmt.Errorf("cannot detect host disk format: %w", err)
+	}
 	disk.Type = "file"
-	disk.Driver.Type = "raw"
+	disk.Driver.Type = format
 	disk.Driver.ErrorPolicy = "stop"
-	disk.Source.File = hostdisk.GetMountedHostDiskPath(volumeName, path)
+	disk.Source.File = file
 	return nil
 }
 
+func getFormat(path string) (string, error) {
+	const (
+		formatQcow2 = "qcow2"
+		formatRaw   = "raw"
+	)
+	info, err := os.Stat(path)
+	if err != nil {
+		if errors.Is(err, os.ErrNotExist) {
+			return formatQcow2, nil
+		}
+		return "", err
+	}
+	mode := info.Mode()
+	if mode&os.ModeDevice != 0 {
+		return formatRaw, nil
+	}
+	return formatQcow2, nil
+}
+
 func Convert_v1_SysprepSource_To_api_Disk(volumeName string, disk *api.Disk) error {
 	if disk.Type == "lun" {
 		return fmt.Errorf(deviceTypeNotCompatibleFmt, disk.Alias.GetName())
