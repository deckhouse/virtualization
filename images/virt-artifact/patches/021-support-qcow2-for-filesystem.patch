diff --git a/pkg/host-disk/host-disk.go b/pkg/host-disk/host-disk.go
index 7ada596d87..f9d6aed9bb 100644
--- a/pkg/host-disk/host-disk.go
+++ b/pkg/host-disk/host-disk.go
@@ -22,6 +22,7 @@ package hostdisk
 import (
 	"fmt"
 	"os"
+	"os/exec"
 	"path"
 	"path/filepath"
 	"syscall"
@@ -171,6 +172,14 @@ func createSparseRaw(fullPath string, size int64) (err error) {
 	return nil
 }
 
+func createQcow2(fullPath string, size int64) (err error) {
+	cmd := exec.Command("qemu-img", "create", "-f", "qcow2", fullPath, fmt.Sprintf("%db", size))
+	if err = cmd.Run(); err != nil {
+		return fmt.Errorf("failed to create qcow2: %w", err)
+	}
+	return nil
+}
+
 func getPVCDiskImgPath(volumeName string, diskName string) string {
 	return path.Join(pvcBaseDir, volumeName, diskName)
 }
@@ -261,7 +270,7 @@ func (hdc *DiskImgCreator) handleRequestedSizeAndCreateSparseRaw(vmi *v1.Virtual
 			return err
 		}
 	}
-	err = createSparseRaw(diskPath, requestedSize)
+	err = createQcow2(diskPath, requestedSize)
 	if err != nil {
 		log.Log.Reason(err).Errorf("Couldn't create a sparse raw file for disk path: %s, error: %v", diskPath, err)
 		return err
diff --git a/pkg/virt-launcher/virtwrap/converter/converter.go b/pkg/virt-launcher/virtwrap/converter/converter.go
index c64b315d8f..4f3dbce5d3 100644
--- a/pkg/virt-launcher/virtwrap/converter/converter.go
+++ b/pkg/virt-launcher/virtwrap/converter/converter.go
@@ -590,7 +590,6 @@ func Add_Agent_To_api_Channel() (channel api.Channel) {
 }
 
 func Convert_v1_Volume_To_api_Disk(source *v1.Volume, disk *api.Disk, c *ConverterContext, diskIndex int) error {
-
 	if source.ContainerDisk != nil {
 		return Convert_v1_ContainerDiskSource_To_api_Disk(source.Name, source.ContainerDisk, disk, c, diskIndex)
 	}
@@ -732,10 +731,16 @@ func Convert_v1_Hotplug_DataVolume_To_api_Disk(name string, disk *api.Disk, c *C
 
 // Convert_v1_FilesystemVolumeSource_To_api_Disk takes a FS source and builds the domain Disk representation
 func Convert_v1_FilesystemVolumeSource_To_api_Disk(volumeName string, disk *api.Disk, volumesDiscardIgnore []string) error {
+	log.DefaultLogger().Infof("DEBUG. Convert_v1_FilesystemVolumeSource_To_api_Disk. convert source volume %s to disk", volumeName)
+	file := GetFilesystemVolumePath(volumeName)
+	info, err := GetImageInfo(file)
+	if err != nil {
+		return fmt.Errorf("failed to get image info: %w", err)
+	}
 	disk.Type = "file"
-	disk.Driver.Type = "raw"
+	disk.Driver.Type = info.Format
 	disk.Driver.ErrorPolicy = "stop"
-	disk.Source.File = GetFilesystemVolumePath(volumeName)
+	disk.Source.File = file
 	if !contains(volumesDiscardIgnore, volumeName) {
 		disk.Driver.Discard = "unmap"
 	}
@@ -744,13 +749,18 @@ func Convert_v1_FilesystemVolumeSource_To_api_Disk(volumeName string, disk *api.
 
 // Convert_v1_Hotplug_FilesystemVolumeSource_To_api_Disk takes a FS source and builds the KVM Disk representation
 func Convert_v1_Hotplug_FilesystemVolumeSource_To_api_Disk(volumeName string, disk *api.Disk, volumesDiscardIgnore []string) error {
+	file := GetHotplugFilesystemVolumePath(volumeName)
+	info, err := GetImageInfo(file)
+	if err != nil {
+		return fmt.Errorf("failed to get image info: %w", err)
+	}
 	disk.Type = "file"
-	disk.Driver.Type = "raw"
+	disk.Driver.Type = info.Format
 	disk.Driver.ErrorPolicy = "stop"
 	if !contains(volumesDiscardIgnore, volumeName) {
 		disk.Driver.Discard = "unmap"
 	}
-	disk.Source.File = GetHotplugFilesystemVolumePath(volumeName)
+	disk.Source.File = file
 	return nil
 }
 
@@ -779,10 +789,15 @@ func Convert_v1_Hotplug_BlockVolumeSource_To_api_Disk(volumeName string, disk *a
 }
 
 func Convert_v1_HostDisk_To_api_Disk(volumeName string, path string, disk *api.Disk) error {
+	file := hostdisk.GetMountedHostDiskPath(volumeName, path)
+	info, err := GetImageInfo(file)
+	if err != nil {
+		return fmt.Errorf("failed to get image info: %w", err)
+	}
 	disk.Type = "file"
-	disk.Driver.Type = "raw"
+	disk.Driver.Type = info.Format
 	disk.Driver.ErrorPolicy = "stop"
-	disk.Source.File = hostdisk.GetMountedHostDiskPath(volumeName, path)
+	disk.Source.File = file
 	return nil
 }
 
@@ -1899,16 +1914,28 @@ func boolToString(value *bool, defaultPositive bool, positive string, negative s
 }
 
 func GetImageInfo(imagePath string) (*containerdisk.DiskInfo, error) {
+	infoFile := fmt.Sprintf("/tmp/info-%s", strings.ReplaceAll(strings.TrimPrefix(imagePath, "/"), "/", "-"))
 
-	// #nosec No risk for attacket injection. Only get information about an image
-	out, err := exec.Command(
-		"/usr/bin/qemu-img", "info", imagePath, "--output", "json",
-	).Output()
+	bytes, err := os.ReadFile(infoFile)
 	if err != nil {
-		return nil, fmt.Errorf("failed to invoke qemu-img: %v", err)
+		if errors.Is(err, os.ErrNotExist) {
+			// #nosec No risk for attacket injection. Only get information about an image
+			bytes, err = exec.Command(
+				"/usr/bin/qemu-img", "info", imagePath, "--output", "json",
+			).Output()
+			if err != nil {
+				return nil, fmt.Errorf("failed to invoke qemu-img: %v", err)
+			}
+			if err = os.WriteFile(infoFile, bytes, 0644); err != nil {
+				return nil, fmt.Errorf("failed to write qemu-img: %v", err)
+			}
+		} else {
+			return nil, fmt.Errorf("failed to read qemu-img info: %v", err)
+		}
 	}
+
 	info := &containerdisk.DiskInfo{}
-	err = json.Unmarshal(out, info)
+	err = json.Unmarshal(bytes, info)
 	if err != nil {
 		return nil, fmt.Errorf("failed to parse disk info: %v", err)
 	}
