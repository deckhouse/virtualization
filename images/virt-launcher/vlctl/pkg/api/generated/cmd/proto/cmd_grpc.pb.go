// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.6
// source: proto/cmd.proto

package cmd

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Cmd_SyncVirtualMachine_FullMethodName              = "/kubevirt.cmd.v1.Cmd/SyncVirtualMachine"
	Cmd_PauseVirtualMachine_FullMethodName             = "/kubevirt.cmd.v1.Cmd/PauseVirtualMachine"
	Cmd_UnpauseVirtualMachine_FullMethodName           = "/kubevirt.cmd.v1.Cmd/UnpauseVirtualMachine"
	Cmd_FreezeVirtualMachine_FullMethodName            = "/kubevirt.cmd.v1.Cmd/FreezeVirtualMachine"
	Cmd_UnfreezeVirtualMachine_FullMethodName          = "/kubevirt.cmd.v1.Cmd/UnfreezeVirtualMachine"
	Cmd_SoftRebootVirtualMachine_FullMethodName        = "/kubevirt.cmd.v1.Cmd/SoftRebootVirtualMachine"
	Cmd_ShutdownVirtualMachine_FullMethodName          = "/kubevirt.cmd.v1.Cmd/ShutdownVirtualMachine"
	Cmd_KillVirtualMachine_FullMethodName              = "/kubevirt.cmd.v1.Cmd/KillVirtualMachine"
	Cmd_DeleteVirtualMachine_FullMethodName            = "/kubevirt.cmd.v1.Cmd/DeleteVirtualMachine"
	Cmd_MigrateVirtualMachine_FullMethodName           = "/kubevirt.cmd.v1.Cmd/MigrateVirtualMachine"
	Cmd_SyncMigrationTarget_FullMethodName             = "/kubevirt.cmd.v1.Cmd/SyncMigrationTarget"
	Cmd_CancelVirtualMachineMigration_FullMethodName   = "/kubevirt.cmd.v1.Cmd/CancelVirtualMachineMigration"
	Cmd_SignalTargetPodCleanup_FullMethodName          = "/kubevirt.cmd.v1.Cmd/SignalTargetPodCleanup"
	Cmd_FinalizeVirtualMachineMigration_FullMethodName = "/kubevirt.cmd.v1.Cmd/FinalizeVirtualMachineMigration"
	Cmd_HotplugHostDevices_FullMethodName              = "/kubevirt.cmd.v1.Cmd/HotplugHostDevices"
	Cmd_GetDomain_FullMethodName                       = "/kubevirt.cmd.v1.Cmd/GetDomain"
	Cmd_GetDomainStats_FullMethodName                  = "/kubevirt.cmd.v1.Cmd/GetDomainStats"
	Cmd_GetGuestInfo_FullMethodName                    = "/kubevirt.cmd.v1.Cmd/GetGuestInfo"
	Cmd_GetUsers_FullMethodName                        = "/kubevirt.cmd.v1.Cmd/GetUsers"
	Cmd_GetFilesystems_FullMethodName                  = "/kubevirt.cmd.v1.Cmd/GetFilesystems"
	Cmd_Ping_FullMethodName                            = "/kubevirt.cmd.v1.Cmd/Ping"
	Cmd_Exec_FullMethodName                            = "/kubevirt.cmd.v1.Cmd/Exec"
	Cmd_GuestPing_FullMethodName                       = "/kubevirt.cmd.v1.Cmd/GuestPing"
	Cmd_VirtualMachineMemoryDump_FullMethodName        = "/kubevirt.cmd.v1.Cmd/VirtualMachineMemoryDump"
	Cmd_GetQemuVersion_FullMethodName                  = "/kubevirt.cmd.v1.Cmd/GetQemuVersion"
	Cmd_SyncVirtualMachineCPUs_FullMethodName          = "/kubevirt.cmd.v1.Cmd/SyncVirtualMachineCPUs"
	Cmd_SyncVirtualMachineMemory_FullMethodName        = "/kubevirt.cmd.v1.Cmd/SyncVirtualMachineMemory"
	Cmd_GetSEVInfo_FullMethodName                      = "/kubevirt.cmd.v1.Cmd/GetSEVInfo"
	Cmd_GetLaunchMeasurement_FullMethodName            = "/kubevirt.cmd.v1.Cmd/GetLaunchMeasurement"
	Cmd_InjectLaunchSecret_FullMethodName              = "/kubevirt.cmd.v1.Cmd/InjectLaunchSecret"
	Cmd_GetAppliedVMIChecksum_FullMethodName           = "/kubevirt.cmd.v1.Cmd/GetAppliedVMIChecksum"
	Cmd_MigrationProxy_FullMethodName                  = "/kubevirt.cmd.v1.Cmd/MigrationProxy"
)

// CmdClient is the client API for Cmd service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CmdClient interface {
	SyncVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	PauseVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	UnpauseVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	FreezeVirtualMachine(ctx context.Context, in *FreezeRequest, opts ...grpc.CallOption) (*Response, error)
	UnfreezeVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	SoftRebootVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	ShutdownVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	KillVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	DeleteVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	MigrateVirtualMachine(ctx context.Context, in *MigrationRequest, opts ...grpc.CallOption) (*Response, error)
	SyncMigrationTarget(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	CancelVirtualMachineMigration(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	SignalTargetPodCleanup(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	FinalizeVirtualMachineMigration(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	HotplugHostDevices(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	GetDomain(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*DomainResponse, error)
	GetDomainStats(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*DomainStatsResponse, error)
	GetGuestInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GuestInfoResponse, error)
	GetUsers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GuestUserListResponse, error)
	GetFilesystems(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GuestFilesystemsResponse, error)
	Ping(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Response, error)
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (*ExecResponse, error)
	GuestPing(ctx context.Context, in *GuestPingRequest, opts ...grpc.CallOption) (*GuestPingResponse, error)
	VirtualMachineMemoryDump(ctx context.Context, in *MemoryDumpRequest, opts ...grpc.CallOption) (*Response, error)
	GetQemuVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*QemuVersionResponse, error)
	SyncVirtualMachineCPUs(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	SyncVirtualMachineMemory(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error)
	GetSEVInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SEVInfoResponse, error)
	GetLaunchMeasurement(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*LaunchMeasurementResponse, error)
	InjectLaunchSecret(ctx context.Context, in *InjectLaunchSecretRequest, opts ...grpc.CallOption) (*Response, error)
	GetAppliedVMIChecksum(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VMIChecksumResponse, error)
	MigrationProxy(ctx context.Context, in *MigrationProxyRequest, opts ...grpc.CallOption) (*Response, error)
}

type cmdClient struct {
	cc grpc.ClientConnInterface
}

func NewCmdClient(cc grpc.ClientConnInterface) CmdClient {
	return &cmdClient{cc}
}

func (c *cmdClient) SyncVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_SyncVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) PauseVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_PauseVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) UnpauseVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_UnpauseVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) FreezeVirtualMachine(ctx context.Context, in *FreezeRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_FreezeVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) UnfreezeVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_UnfreezeVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) SoftRebootVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_SoftRebootVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) ShutdownVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_ShutdownVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) KillVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_KillVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) DeleteVirtualMachine(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_DeleteVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) MigrateVirtualMachine(ctx context.Context, in *MigrationRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_MigrateVirtualMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) SyncMigrationTarget(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_SyncMigrationTarget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) CancelVirtualMachineMigration(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_CancelVirtualMachineMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) SignalTargetPodCleanup(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_SignalTargetPodCleanup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) FinalizeVirtualMachineMigration(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_FinalizeVirtualMachineMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) HotplugHostDevices(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_HotplugHostDevices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetDomain(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*DomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DomainResponse)
	err := c.cc.Invoke(ctx, Cmd_GetDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetDomainStats(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*DomainStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DomainStatsResponse)
	err := c.cc.Invoke(ctx, Cmd_GetDomainStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetGuestInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GuestInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuestInfoResponse)
	err := c.cc.Invoke(ctx, Cmd_GetGuestInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetUsers(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GuestUserListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuestUserListResponse)
	err := c.cc.Invoke(ctx, Cmd_GetUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetFilesystems(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*GuestFilesystemsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuestFilesystemsResponse)
	err := c.cc.Invoke(ctx, Cmd_GetFilesystems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) Ping(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (*ExecResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecResponse)
	err := c.cc.Invoke(ctx, Cmd_Exec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GuestPing(ctx context.Context, in *GuestPingRequest, opts ...grpc.CallOption) (*GuestPingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GuestPingResponse)
	err := c.cc.Invoke(ctx, Cmd_GuestPing_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) VirtualMachineMemoryDump(ctx context.Context, in *MemoryDumpRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_VirtualMachineMemoryDump_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetQemuVersion(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*QemuVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QemuVersionResponse)
	err := c.cc.Invoke(ctx, Cmd_GetQemuVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) SyncVirtualMachineCPUs(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_SyncVirtualMachineCPUs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) SyncVirtualMachineMemory(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_SyncVirtualMachineMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetSEVInfo(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SEVInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SEVInfoResponse)
	err := c.cc.Invoke(ctx, Cmd_GetSEVInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetLaunchMeasurement(ctx context.Context, in *VMIRequest, opts ...grpc.CallOption) (*LaunchMeasurementResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LaunchMeasurementResponse)
	err := c.cc.Invoke(ctx, Cmd_GetLaunchMeasurement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) InjectLaunchSecret(ctx context.Context, in *InjectLaunchSecretRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_InjectLaunchSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) GetAppliedVMIChecksum(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*VMIChecksumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VMIChecksumResponse)
	err := c.cc.Invoke(ctx, Cmd_GetAppliedVMIChecksum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cmdClient) MigrationProxy(ctx context.Context, in *MigrationProxyRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, Cmd_MigrationProxy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CmdServer is the server API for Cmd service.
// All implementations must embed UnimplementedCmdServer
// for forward compatibility.
type CmdServer interface {
	SyncVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	PauseVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	UnpauseVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	FreezeVirtualMachine(context.Context, *FreezeRequest) (*Response, error)
	UnfreezeVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	SoftRebootVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	ShutdownVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	KillVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	DeleteVirtualMachine(context.Context, *VMIRequest) (*Response, error)
	MigrateVirtualMachine(context.Context, *MigrationRequest) (*Response, error)
	SyncMigrationTarget(context.Context, *VMIRequest) (*Response, error)
	CancelVirtualMachineMigration(context.Context, *VMIRequest) (*Response, error)
	SignalTargetPodCleanup(context.Context, *VMIRequest) (*Response, error)
	FinalizeVirtualMachineMigration(context.Context, *VMIRequest) (*Response, error)
	HotplugHostDevices(context.Context, *VMIRequest) (*Response, error)
	GetDomain(context.Context, *EmptyRequest) (*DomainResponse, error)
	GetDomainStats(context.Context, *EmptyRequest) (*DomainStatsResponse, error)
	GetGuestInfo(context.Context, *EmptyRequest) (*GuestInfoResponse, error)
	GetUsers(context.Context, *EmptyRequest) (*GuestUserListResponse, error)
	GetFilesystems(context.Context, *EmptyRequest) (*GuestFilesystemsResponse, error)
	Ping(context.Context, *EmptyRequest) (*Response, error)
	Exec(context.Context, *ExecRequest) (*ExecResponse, error)
	GuestPing(context.Context, *GuestPingRequest) (*GuestPingResponse, error)
	VirtualMachineMemoryDump(context.Context, *MemoryDumpRequest) (*Response, error)
	GetQemuVersion(context.Context, *EmptyRequest) (*QemuVersionResponse, error)
	SyncVirtualMachineCPUs(context.Context, *VMIRequest) (*Response, error)
	SyncVirtualMachineMemory(context.Context, *VMIRequest) (*Response, error)
	GetSEVInfo(context.Context, *EmptyRequest) (*SEVInfoResponse, error)
	GetLaunchMeasurement(context.Context, *VMIRequest) (*LaunchMeasurementResponse, error)
	InjectLaunchSecret(context.Context, *InjectLaunchSecretRequest) (*Response, error)
	GetAppliedVMIChecksum(context.Context, *EmptyRequest) (*VMIChecksumResponse, error)
	MigrationProxy(context.Context, *MigrationProxyRequest) (*Response, error)
	mustEmbedUnimplementedCmdServer()
}

// UnimplementedCmdServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCmdServer struct{}

func (UnimplementedCmdServer) SyncVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncVirtualMachine not implemented")
}
func (UnimplementedCmdServer) PauseVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseVirtualMachine not implemented")
}
func (UnimplementedCmdServer) UnpauseVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnpauseVirtualMachine not implemented")
}
func (UnimplementedCmdServer) FreezeVirtualMachine(context.Context, *FreezeRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FreezeVirtualMachine not implemented")
}
func (UnimplementedCmdServer) UnfreezeVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnfreezeVirtualMachine not implemented")
}
func (UnimplementedCmdServer) SoftRebootVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SoftRebootVirtualMachine not implemented")
}
func (UnimplementedCmdServer) ShutdownVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutdownVirtualMachine not implemented")
}
func (UnimplementedCmdServer) KillVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillVirtualMachine not implemented")
}
func (UnimplementedCmdServer) DeleteVirtualMachine(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVirtualMachine not implemented")
}
func (UnimplementedCmdServer) MigrateVirtualMachine(context.Context, *MigrationRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateVirtualMachine not implemented")
}
func (UnimplementedCmdServer) SyncMigrationTarget(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncMigrationTarget not implemented")
}
func (UnimplementedCmdServer) CancelVirtualMachineMigration(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelVirtualMachineMigration not implemented")
}
func (UnimplementedCmdServer) SignalTargetPodCleanup(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalTargetPodCleanup not implemented")
}
func (UnimplementedCmdServer) FinalizeVirtualMachineMigration(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinalizeVirtualMachineMigration not implemented")
}
func (UnimplementedCmdServer) HotplugHostDevices(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HotplugHostDevices not implemented")
}
func (UnimplementedCmdServer) GetDomain(context.Context, *EmptyRequest) (*DomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDomain not implemented")
}
func (UnimplementedCmdServer) GetDomainStats(context.Context, *EmptyRequest) (*DomainStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDomainStats not implemented")
}
func (UnimplementedCmdServer) GetGuestInfo(context.Context, *EmptyRequest) (*GuestInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuestInfo not implemented")
}
func (UnimplementedCmdServer) GetUsers(context.Context, *EmptyRequest) (*GuestUserListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedCmdServer) GetFilesystems(context.Context, *EmptyRequest) (*GuestFilesystemsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFilesystems not implemented")
}
func (UnimplementedCmdServer) Ping(context.Context, *EmptyRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedCmdServer) Exec(context.Context, *ExecRequest) (*ExecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exec not implemented")
}
func (UnimplementedCmdServer) GuestPing(context.Context, *GuestPingRequest) (*GuestPingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GuestPing not implemented")
}
func (UnimplementedCmdServer) VirtualMachineMemoryDump(context.Context, *MemoryDumpRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VirtualMachineMemoryDump not implemented")
}
func (UnimplementedCmdServer) GetQemuVersion(context.Context, *EmptyRequest) (*QemuVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQemuVersion not implemented")
}
func (UnimplementedCmdServer) SyncVirtualMachineCPUs(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncVirtualMachineCPUs not implemented")
}
func (UnimplementedCmdServer) SyncVirtualMachineMemory(context.Context, *VMIRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncVirtualMachineMemory not implemented")
}
func (UnimplementedCmdServer) GetSEVInfo(context.Context, *EmptyRequest) (*SEVInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSEVInfo not implemented")
}
func (UnimplementedCmdServer) GetLaunchMeasurement(context.Context, *VMIRequest) (*LaunchMeasurementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLaunchMeasurement not implemented")
}
func (UnimplementedCmdServer) InjectLaunchSecret(context.Context, *InjectLaunchSecretRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InjectLaunchSecret not implemented")
}
func (UnimplementedCmdServer) GetAppliedVMIChecksum(context.Context, *EmptyRequest) (*VMIChecksumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppliedVMIChecksum not implemented")
}
func (UnimplementedCmdServer) MigrationProxy(context.Context, *MigrationProxyRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrationProxy not implemented")
}
func (UnimplementedCmdServer) mustEmbedUnimplementedCmdServer() {}
func (UnimplementedCmdServer) testEmbeddedByValue()             {}

// UnsafeCmdServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CmdServer will
// result in compilation errors.
type UnsafeCmdServer interface {
	mustEmbedUnimplementedCmdServer()
}

func RegisterCmdServer(s grpc.ServiceRegistrar, srv CmdServer) {
	// If the following call pancis, it indicates UnimplementedCmdServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Cmd_ServiceDesc, srv)
}

func _Cmd_SyncVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).SyncVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_SyncVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).SyncVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_PauseVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).PauseVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_PauseVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).PauseVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_UnpauseVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).UnpauseVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_UnpauseVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).UnpauseVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_FreezeVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FreezeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).FreezeVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_FreezeVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).FreezeVirtualMachine(ctx, req.(*FreezeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_UnfreezeVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).UnfreezeVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_UnfreezeVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).UnfreezeVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_SoftRebootVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).SoftRebootVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_SoftRebootVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).SoftRebootVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_ShutdownVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).ShutdownVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_ShutdownVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).ShutdownVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_KillVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).KillVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_KillVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).KillVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_DeleteVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).DeleteVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_DeleteVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).DeleteVirtualMachine(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_MigrateVirtualMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).MigrateVirtualMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_MigrateVirtualMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).MigrateVirtualMachine(ctx, req.(*MigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_SyncMigrationTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).SyncMigrationTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_SyncMigrationTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).SyncMigrationTarget(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_CancelVirtualMachineMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).CancelVirtualMachineMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_CancelVirtualMachineMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).CancelVirtualMachineMigration(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_SignalTargetPodCleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).SignalTargetPodCleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_SignalTargetPodCleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).SignalTargetPodCleanup(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_FinalizeVirtualMachineMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).FinalizeVirtualMachineMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_FinalizeVirtualMachineMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).FinalizeVirtualMachineMigration(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_HotplugHostDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).HotplugHostDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_HotplugHostDevices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).HotplugHostDevices(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetDomain(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetDomainStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetDomainStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetDomainStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetDomainStats(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetGuestInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetGuestInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetGuestInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetGuestInfo(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetUsers(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetFilesystems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetFilesystems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetFilesystems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetFilesystems(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).Ping(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_Exec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).Exec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_Exec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).Exec(ctx, req.(*ExecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GuestPing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GuestPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GuestPing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GuestPing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GuestPing(ctx, req.(*GuestPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_VirtualMachineMemoryDump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryDumpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).VirtualMachineMemoryDump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_VirtualMachineMemoryDump_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).VirtualMachineMemoryDump(ctx, req.(*MemoryDumpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetQemuVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetQemuVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetQemuVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetQemuVersion(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_SyncVirtualMachineCPUs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).SyncVirtualMachineCPUs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_SyncVirtualMachineCPUs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).SyncVirtualMachineCPUs(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_SyncVirtualMachineMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).SyncVirtualMachineMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_SyncVirtualMachineMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).SyncVirtualMachineMemory(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetSEVInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetSEVInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetSEVInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetSEVInfo(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetLaunchMeasurement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetLaunchMeasurement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetLaunchMeasurement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetLaunchMeasurement(ctx, req.(*VMIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_InjectLaunchSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InjectLaunchSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).InjectLaunchSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_InjectLaunchSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).InjectLaunchSecret(ctx, req.(*InjectLaunchSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_GetAppliedVMIChecksum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).GetAppliedVMIChecksum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_GetAppliedVMIChecksum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).GetAppliedVMIChecksum(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cmd_MigrationProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrationProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CmdServer).MigrationProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cmd_MigrationProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CmdServer).MigrationProxy(ctx, req.(*MigrationProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Cmd_ServiceDesc is the grpc.ServiceDesc for Cmd service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cmd_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kubevirt.cmd.v1.Cmd",
	HandlerType: (*CmdServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncVirtualMachine",
			Handler:    _Cmd_SyncVirtualMachine_Handler,
		},
		{
			MethodName: "PauseVirtualMachine",
			Handler:    _Cmd_PauseVirtualMachine_Handler,
		},
		{
			MethodName: "UnpauseVirtualMachine",
			Handler:    _Cmd_UnpauseVirtualMachine_Handler,
		},
		{
			MethodName: "FreezeVirtualMachine",
			Handler:    _Cmd_FreezeVirtualMachine_Handler,
		},
		{
			MethodName: "UnfreezeVirtualMachine",
			Handler:    _Cmd_UnfreezeVirtualMachine_Handler,
		},
		{
			MethodName: "SoftRebootVirtualMachine",
			Handler:    _Cmd_SoftRebootVirtualMachine_Handler,
		},
		{
			MethodName: "ShutdownVirtualMachine",
			Handler:    _Cmd_ShutdownVirtualMachine_Handler,
		},
		{
			MethodName: "KillVirtualMachine",
			Handler:    _Cmd_KillVirtualMachine_Handler,
		},
		{
			MethodName: "DeleteVirtualMachine",
			Handler:    _Cmd_DeleteVirtualMachine_Handler,
		},
		{
			MethodName: "MigrateVirtualMachine",
			Handler:    _Cmd_MigrateVirtualMachine_Handler,
		},
		{
			MethodName: "SyncMigrationTarget",
			Handler:    _Cmd_SyncMigrationTarget_Handler,
		},
		{
			MethodName: "CancelVirtualMachineMigration",
			Handler:    _Cmd_CancelVirtualMachineMigration_Handler,
		},
		{
			MethodName: "SignalTargetPodCleanup",
			Handler:    _Cmd_SignalTargetPodCleanup_Handler,
		},
		{
			MethodName: "FinalizeVirtualMachineMigration",
			Handler:    _Cmd_FinalizeVirtualMachineMigration_Handler,
		},
		{
			MethodName: "HotplugHostDevices",
			Handler:    _Cmd_HotplugHostDevices_Handler,
		},
		{
			MethodName: "GetDomain",
			Handler:    _Cmd_GetDomain_Handler,
		},
		{
			MethodName: "GetDomainStats",
			Handler:    _Cmd_GetDomainStats_Handler,
		},
		{
			MethodName: "GetGuestInfo",
			Handler:    _Cmd_GetGuestInfo_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _Cmd_GetUsers_Handler,
		},
		{
			MethodName: "GetFilesystems",
			Handler:    _Cmd_GetFilesystems_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Cmd_Ping_Handler,
		},
		{
			MethodName: "Exec",
			Handler:    _Cmd_Exec_Handler,
		},
		{
			MethodName: "GuestPing",
			Handler:    _Cmd_GuestPing_Handler,
		},
		{
			MethodName: "VirtualMachineMemoryDump",
			Handler:    _Cmd_VirtualMachineMemoryDump_Handler,
		},
		{
			MethodName: "GetQemuVersion",
			Handler:    _Cmd_GetQemuVersion_Handler,
		},
		{
			MethodName: "SyncVirtualMachineCPUs",
			Handler:    _Cmd_SyncVirtualMachineCPUs_Handler,
		},
		{
			MethodName: "SyncVirtualMachineMemory",
			Handler:    _Cmd_SyncVirtualMachineMemory_Handler,
		},
		{
			MethodName: "GetSEVInfo",
			Handler:    _Cmd_GetSEVInfo_Handler,
		},
		{
			MethodName: "GetLaunchMeasurement",
			Handler:    _Cmd_GetLaunchMeasurement_Handler,
		},
		{
			MethodName: "InjectLaunchSecret",
			Handler:    _Cmd_InjectLaunchSecret_Handler,
		},
		{
			MethodName: "GetAppliedVMIChecksum",
			Handler:    _Cmd_GetAppliedVMIChecksum_Handler,
		},
		{
			MethodName: "MigrationProxy",
			Handler:    _Cmd_MigrationProxy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/cmd.proto",
}
