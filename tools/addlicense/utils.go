/*
Copyright 2024 Flant JSC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

func isShebangLine(line string) bool {
	return strings.HasPrefix(line, "#!")
}

func closeFile(f *os.File) {
	err := f.Close()
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func getLicenseForFile(filePath string) string {
	switch filepath.Ext(filePath) {
	case ".go":
		return goLicense
	case ".py", ".sh", ".bash", ".zsh", ".yaml", ".yml":
		return bashPythonLicense
	default:
		return ""
	}
}

func checkLicense(fullContent []byte, filePath string) (Message, bool) {
	if CELicenseRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File already contains CE license")
		return msg, true
	}

	if copyrightOrAutogenRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File already contains autogenerated license")
		return msg, true
	}

	if flantRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File already contains Flant license")
		return msg, true
	}

	if copyrightRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File contains other license")
		return msg, true
	}

	return Message{}, false
}

func addLicenseToFile(filePath, licenseFileText string) Message {
	f, err := os.Open(filePath)
	if err != nil {
		message := NewError(filePath, "Error opening file", err.Error())
		return message
	}
	defer closeFile(f)

	reader := bufio.NewReader(f)

	fullContent, err := io.ReadAll(reader)
	if err != nil {
		message := NewError(filePath, "Failed to read rest of file", err.Error())
		return message
	}

	firstLine, restOfFile, _ := strings.Cut(string(fullContent), "\n")

	message, license := checkLicense(fullContent, filePath)
	var newContent bytes.Buffer

	if !license && (Message{}) == message {
		if isShebangLine(firstLine) {
			newContent.WriteString(firstLine)
			newContent.WriteString("\n\n")
			newContent.WriteString(licenseFileText)
			newContent.WriteString(restOfFile)
		} else {
			newContent.WriteString(licenseFileText)
			newContent.WriteString("\n")
			newContent.WriteString(string(fullContent))
		}
	} else {
		return message
	}

	err = os.WriteFile(filePath, newContent.Bytes(), 0o644)
	if err != nil {
		return NewError(filePath, "Failed to write file", err.Error())
	}

	return NewAdd(filePath)
}
