package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

func isShebangLine(line string) bool {
	return strings.HasPrefix(line, "#!")
}

func closeFile(f *os.File) {
	err := f.Close()
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func getLicenseForFile(filePath string) string {
	switch filepath.Ext(filePath) {
	case ".go":
		return goLicense
	case ".py", ".sh", ".bash", ".zsh":
		return bashPythonLicense
	default:
		return ""
	}
}

func checkLicense(fullContent []byte, filePath string) (Message, bool) {
	if CELicenseRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File already contains CE license")
		return msg, true
	}

	if copyrightOrAutogenRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File already contains autogenerated license")
		return msg, true
	}

	if flantRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File already contains Flant license")
		return msg, true
	}

	if copyrightRe.MatchString(string(fullContent)) {
		msg := NewSkip(filePath, "File contains other license")
		return msg, true
	}

	return Message{}, false
}

func addLicenseToFile(filePath, license string) Message {
	f, err := os.Open(filePath)
	if err != nil {
		message := NewError(filePath, "Error opening file", err.Error())
		return message
	}
	defer closeFile(f)

	reader := bufio.NewReader(f)

	fullContent, err := io.ReadAll(reader)
	if err != nil {
		message := NewError(filePath, "Failed to read rest of file", err.Error())
		return message
	}

	firstLine, restOfFile, _ := strings.Cut(string(fullContent), "\n")

	message, lic := checkLicense(fullContent, filePath)
	var newContent bytes.Buffer

	if !lic {
		if isShebangLine(firstLine) {
			newContent.WriteString(firstLine)
			newContent.WriteString("\n\n")
			newContent.WriteString(license)
			newContent.WriteString(restOfFile)
		} else {
			newContent.WriteString(license)
			newContent.WriteString("\n\n")
			newContent.WriteString(firstLine)
			newContent.WriteString(restOfFile)
		}
	} else {
		return message
	}

	err = os.WriteFile(filePath, newContent.Bytes(), 0644)

	if err != nil {
		return NewError(filePath, "Failed to write file", err.Error())
	}

	return NewAdd(filePath)
}
